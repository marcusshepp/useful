UI
committee-reports container
|
|_ committee-reports
|  |_ committee-reports-agenda-item
|  |  |_ committee-reports-actions
|  |  |_ committee-reports-roll-call


API

- Navigation properties from committeReports to 
    committeeReportsAgendaItems

Data needed for Committee Report:
- Session
- Committee
- Meeting
- Is Published
- Published Date
- Addenda Date
- Attendance Published By
- Attendance Published Date
- Is Attendance Published
- Published Document
- Published Attendance Document

What I did so far:
- Make a new directory for committee report models

- Create a new model for CommitteeReportAgendaItem
    - this gets rid of the need for: 
        - CommitteeReportCommitteeActionToAgendaItem
        - CommitteeReportPublishedItems

- Create a new model for CommitteeReportAction
    - this gets rid of the need for: 
        - CommitteeReportCommitteeAction
        - CommitteeReportCommitteeActionToAgendaItem
        - CommitteeReportPublishedActions
    


V2
How are we doing agenda items right now? Agenda items are stored with the committee meeting in shared db.


Upon publishing or republishing the notice, agenda items for meeting will be copied to report, then the report will match the meeting.





Migration Plan

Problem: 
    Current migration file drops tables that I need to populate the new tables before
    creating the new tables

Solution(s):
    1. full migration with pre-defined back up 
    - Take a back up of the data
    - Use python to create a list of json objects that
        are in the db structure I need for the new schema,
        this will pull all the data I need from eva and shared
    - Run the migration
    - Run another script that will use the json data to populate the new tables

    2. incremental migration
    - Take a back up of the data
    - Run first migration: Create tables
    - Run a script that will populate the new tables with the data from the old tables
        - this script should have detailed logging
        - this script should be able to be run multiple times without duplicating data
    - Run second migration: Drop old tables
    - Use an env var for 'should this env run its migrations automatically'
    - this would use the dotnet cli to run each migration incrementally via the update command
    * Biggest problem here is committee report table is named the same. 
    * Could just create a new table for it "CommitteeReportV2" and then copy the data over
    * This would require dotnet CLI to be installed on the higher environments



























































Brians Notes:
so there's a few things that jump out just looking at the committee reports service:
just code smell, i just scroll through that file and think "it shouldn't be this complicated/complex"/1200+ lines seems like a lot to do all this
the recently added CommitteeReportPublishedActions table that is identical to the CommitteeReportCommitteeActionToAgendaItem table, just add a IsPublished flag to that and have all records in the one spot... now the code doesn't have to convert/clone objects to use them in the same spot (report generator), nor are two different queries necessary
Some sort of owning object for a CommitteeReport that has navigation properties for the other committee report data, so one query can be done to get all the data for a committee report
All the "new"ing up of objects converting data to dtos... not sure what the the aversion is to using automapper (yes i know it doesn't work in every scenario: ie merging more than one object into one), but constantly creating objects in numerous spots gives a much bigger window to mistakes/inconsistencies than having one definition of how to convert stuff
overall my approach, if i was doing this, was going to be to just design a new database schema based off everything we know about committee reports and work from there... this way i'm not influenced with how its already designed



----

        public CommitteeReportDto GetCommitteeReportDto(int sessionId, int committeeId, int meetingId, bool onlyPublished)
        {
            Session session = ValidateSession(sessionId);
            Committee committee = (committee = _sharedDb.Committee
                .FirstOrDefault(c =>
                    c.IsActive &&
                    c.SessionId == session.LsbId &&
                    c.Id == committeeId)) ?? throw new FileNotFoundException("Cannot find Committee");

            CommitteeMeeting meeting = _sharedDb.CommitteeMeeting
                .Include(cm => cm.CommitteeMeetingCommittee)
                    .ThenInclude(cmc => cmc.Committee)
                .FirstOrDefault(m =>
                    m.ChamberId == (int)M2Chambers.Senate &&
                    m.SessionId == session.LsbId &&
                    m.IsActive &&
                    m.Id == meetingId) ?? throw new FileNotFoundException("Cannot find meeting");

            HashSet<int> removedAgendaItems = _evaDb.CommitteeReportRemovedAgendaItems
                .Where(ri => ri.MeetingId == meetingId)
                .Select(ri => ri.AgendaItemId)
                .ToHashSet();

            CommitteeReportDto dto = new();
            CommitteeReport report = _evaDb.CommitteeReports
                .FirstOrDefault(r => r.MeetingId == meetingId && r.CommitteeId == committeeId);
            dto.AttendanceRecords = _attendanceService
                .GetMeetingAttendanceForMeeting(sessionId, committeeId, meetingId);
            dto.AgendaItems = _meetingService
                .GetCommitteeMeetingAgendaItems(sessionId, committeeId, meetingId, true, false)
                .Where(ai => !removedAgendaItems.Contains(ai.AgendaItemId.Value))
                .ToList();

            if (onlyPublished)
            {
                HashSet<int> publishedAgendaIds = _evaDb.CommitteeReportPublishedItems
                    .Where(pi => pi.MeetingId == meetingId)
                    .Select(pi => pi.AgendaItemId)
                    .ToHashSet();

                dto.AgendaItems = dto.AgendaItems
                    .Where(ai => ai.AgendaItemId.HasValue && publishedAgendaIds.Contains(ai.AgendaItemId.Value))
                    .ToList();

                List<CommitteeReportPublishedActions> publishedActions = _evaDb.CommitteeReportPublishedActions
                    .Where(pa => pa.MeetingId == meetingId)
                    .ToList();

                if (publishedActions != null && publishedActions.Any())
                {
                    foreach (CommitteeMeetingAgendaItemDto item in dto.AgendaItems)
                    {
                        if (item.Actions != null && item.Actions.Any())
                        {
                            item.Actions = item.Actions
                                .Where(a => publishedActions.Any(pa =>
                                    pa.AgendaItemId == item.AgendaItemId &&
                                    pa.CommitteeReportCommitteeActionId == (a.ActionId ?? 0)))
                                .ToList();
                        }
                    }
                }
            }

            // all actions for all agenda items
            List<CommitteeReportCommitteeActionToAgendaItem> agendaActions = _evaDb.CommitteeReportCommitteeActionToAgendaItems
                .Include(a => a.CommitteeReportCommitteeAction)
                .Where(a => a.MeetingId == meetingId)
                .ToList();
            // all rollcalls for all agenda items
            List<CommitteeMemberRollCall> agendaRollCalls = _evaDb.CommitteeMemberRollCalls
                .Where(a =>
                    dto.AgendaItems.Select(i => i.AgendaItemId).Contains(a.AgendaItemId) &&
                    dto.AttendanceRecords.Select(r => r.CommitteeMemberId).Contains(a.MemberId))
                .ToList();

            if (report != null)
            {
                dto.Id = report.Id;
                dto.IsPublished = report.IsPublished;
                dto.PublishedDate = report.PublishedDate;
                dto.IsAttendancePublished = report.IsAttendancePublished;
                dto.AttendancePublishedDate = report.AttendancePublishedDate;

                for (int i = 0; i < dto.AgendaItems.Count(); i++)
                {
                    CommitteeMeetingAgendaItemDto item = dto.AgendaItems.ElementAt(i);

                    item.Actions = agendaActions
                        .Where(a => a.AgendaItemId == item.AgendaItemId)
                        .Select(a => new CommitteeReportAgendaItemToActionDto
                        {
                            ActionId = a.CommitteeReportCommitteeActionId,
                            AgendaItemId = a.AgendaItemId,
                            Sub = a.Sub,
                            SortOrder = a.SortOrder,
                            CustomRecommendedAction = a.CustomRecommendedAction,
                            CustomReportOutAction = a.CustomReportOutAction,
                        })
                        .OrderBy(a => a.SortOrder)
                        .ToList();
                    if (agendaRollCalls == null || agendaRollCalls.Count == 0)
                    {
                        item.MemberRollCalls = dto.AttendanceRecords
                            .Select(a => new CommitteeMemberRollCallDto
                            {
                                MemberId = a.CommitteeMemberId,
                                MemberName = a.MemberName,
                                RoleCallVote = null
                            })
                        .ToList();
                    }
                    else
                    {
                        item.MemberRollCalls = agendaRollCalls
                            .Where(a => a.AgendaItemId == item.AgendaItemId)
                            .Select(a => new CommitteeMemberRollCallDto
                            {
                                MemberId = a.MemberId,
                                MemberName = dto.AttendanceRecords.FirstOrDefault(c => c.CommitteeMemberId == a.MemberId)?.MemberName,
                                RoleCallVote = a.RoleCallVote
                            })
                            .ToList();
                    }
                }
            }
            else
            {
                for (int i = 0; i < dto.AgendaItems.Count(); i++)
                {
                    CommitteeMeetingAgendaItemDto item = dto.AgendaItems.ElementAt(i);

                    item.MemberRollCalls = new List<CommitteeMemberRollCallDto>();
                    for (int y = 0; y < dto.AttendanceRecords.Count(); y++)
                    {
                        AttendanceRecordDto record = dto.AttendanceRecords.ElementAt(y);
                        CommitteeMemberRollCallDto committeeMemberRollCallDto = new()
                        {
                            MemberId = record.CommitteeMemberId,
                            MemberName = record.MemberName,
                            RoleCallVote = null,
                            AgendaItemDescription = item.Description,
                            AgendaItemIdentifier = item.Identifier,
                            AgendaItemPrefix = item.Prefix,
                        };
                        item.MemberRollCalls.Add(committeeMemberRollCallDto);
                    }
                }
            }

            dto.CommitteeName = committee.CommitteeName;
            dto.MeetingDate = meeting.MeetingDate;
            dto.MeetingTime = meeting.MeetingTime;
            dto.MeetingLocation = meeting.MeetingLocation;

            dto.JointCommittees = _meetingService
                .GetCommitteeMeetingJointCommittees(sessionId, committeeId, meetingId);
            return dto;
        }


        using EvaAPI.Data.M2.Models.Locations;
using System.ComponentModel.DataAnnotations.Schema;

namespace EvaAPI.Data.M2.Models.Committees
{
    public class Committee : IModifiedInfo, IAddedDate
    {
        [Column("CommitteeID")]
        public int Id { get; set; }
        public int CommitteeTypeId { get; set; }
        public int SessionId { get; set; }
        public int ChamberId { get; set; }
        public int? ChairId { get; set; }
        public int? ClerkId { get; set; }
        public int? LocationId { get; set; }
        public string CommitteePhone { get; set; }
        public string CommitteeName { get; set; }
        public string IntegrationName { get; set; }
        public string NameCode { get; set; }
        public bool IsAfterSession { get; set; }
        public bool IsActive { get; set; }
        public bool IsPublic { get; set; }
        public int? CommitteeParentId { get; set; }
        public string MeetingDay { get; set; }
        public string MeetingTime { get; set; }
        public DateTime DateAdded { get; set; }
        public DateTime LastModified { get; set; }
        public string LastModifiedBy { get; set; }
        public string Website { get; set; }
        public int? ListServId { get; set; }
        public virtual CommitteeType CommitteeType { get; set; }
        public virtual ListServ ListServ { get; set; }
        [ForeignKey(nameof(CommitteeParentId))]
        public virtual Committee ParentCommittee { get; set; }
        public virtual ICollection<CommitteeMember> Members { get; set; }
        public virtual Location Location { get; set; }
        
    }
}
using EvaAPI.Data.Interfaces;
using EvaAPI.Data.M2.Models.Locations;
using System.ComponentModel.DataAnnotations.Schema;

namespace EvaAPI.Data.M2.Models.Committees
{
    public class CommitteeMeeting : IAddedDate, IModifiedInfo
    {
        [Column("CommitteeMeetingID")]
        public int Id { get; set; }
        public int SessionId { get; set; }
        public int ChamberId { get; set; }
        public DateTime MeetingDate { get; set; }
        public string MeetingTime { get; set; }
        public string MeetingLocation { get; set; }
        public int? LocationId { get; set; }
        public string MeetingNotes { get; set; }
        public int? MeetingStatusTypeID { get; set; }
        public bool IsPublished { get; set; }
        public DateTime? DatePublished { get; set; }
        public int? ChairId { get; set; }
        public string ChairCode { get; set; }
        public int? ClerkId { get; set; }
        public bool IsJointCommittee { get; set; }
        public int SameDaySortOrder { get; set; }
        public bool IsAfterSession { get; set; }
        public bool AOBLanguageUsed { get; set; }
        public bool IsPublic { get; set; }
        public bool IsEditing { get; set; }
        public DateTime DateAdded { get; set; }
        public DateTime LastModified { get; set; }
        public string LastModifiedBy { get; set; }
        public bool IsActive { get; set; }
        public virtual Location Location { get; set; }
        public virtual UserProfile Clerk { get; set; }
        public virtual ICollection<CommitteeMeetingCommittee> CommitteeMeetingCommittee { get; set; }
        public virtual ICollection<CommitteeMeetingAgendaItem> CommitteeMeetingAgendaItems { get; set; }
    }
}


using EvaAPI.Data.Common;

namespace EvaAPI.Data.Models.Committees
{
    public class CommitteeReport : TrackableEntity
    {
        public int SessionId { get; set; }
        public int CommitteeId { get; set; }
        public int MeetingId { get; set; }
        public bool IsPublished { get; set; }
        public DateTime? PublishedDate { get; set; }
        public DateTime? AddendaDate { get; set; }
        public string PublishedBy { get; set; }
        public string AttendancePublishedBy { get; set; }
        public bool IsAttendancePublished { get; set; }
        public DateTime? AttendancePublishedDate { get; set; }
        public byte[] PublishedReportDocument { get; set; }
        public byte[] PublishedAttendanceReportDocument { get; set; }
    }
}
namespace EvaAPI.Data.Models.Committees
{
    public class CommitteeReportPublishedActions 
    {
        public int Id { get; set; }
        public int MeetingId { get; set; }
        public int AgendaItemId { get; set; }
        public string Sub { get; set; }
        public int SortOrder { get; set; }
        public int? CommitteeReportCommitteeActionId { get; set; }
        public string CustomReportOutAction { get; set; }
        public string CustomRecommendedAction { get; set; }
        public virtual CommitteeReportCommitteeAction CommitteeReportCommitteeAction { get; set; }
    }
}
namespace EvaAPI.Data.Models.Committees
{
    public class CommitteeReportCommitteeActionToAgendaItem
    {
        public int Id { get; set; }
        public int MeetingId { get; set; }
        public int AgendaItemId { get; set; }
        public string Sub { get; set; }
        public int SortOrder { get; set; }
        public int? CommitteeReportCommitteeActionId { get; set; }
        public string CustomReportOutAction { get; set; }
        public string CustomRecommendedAction { get; set; }
        public virtual CommitteeReportCommitteeAction CommitteeReportCommitteeAction { get; set; }
    }
}
using EvaAPI.Data.Common;

namespace EvaAPI.Data.Models.Reports
{
    public class CommitteeMemberRollCall : TrackableEntity
    {
        public int SessionId { get; set; }
        public int CommitteeId { get; set; }
        public int MeetingId { get; set; }
        public int MemberId { get; set; }
        public int AgendaItemId { get; set; }
        public string RoleCallVote { get; set; }
        public DateTime? PublishedDate { get; set; }
        public DateTime? AddendaDate { get; set; }
        public string PublishedBy { get; set; }
    }
}

There are two db's here, shared and eva

eva is the application I'm working with it is part of an ecosystem of apps that 
share the shared db.
I need to refactor the committee reports service to make it more efficient and
easier to read and easier to maintain.
I want to start by creating a new database schema based off everything we know
about committee reports and work from there.
The committee report model is the model that I need to start with.

The committee report reports on the commmittee meeting its tied to. 
The committee report is in eva db the committee and the meeting is in the shared db.
the committee meeting and its list of agenda items are in the shared db.
The committee report has a list of agenda items that are tied to the committee meeting.
The committee report has a list of committee report actions that are tied to the agenda items.
The committee report has a list of committee member roll calls that are tied to the agenda items.

Output five options for how I could rewrite the model such that it would 
make querying for a committee report achievable in a single query.

I will choose from these options as I refactor the committee reports service.


proposal 1:
# Committee Report Refactoring Project Context Document

## Current Situation

The application currently consists of two databases:
- **Shared DB**: Contains core data models including Committee, CommitteeMeeting, CommitteeMeetingAgendaItem, and related entities
- **Eva DB**: Contains Committee Report data and related tracking information

The Committee Report service needs to obtain data from both databases to build a complete report. The current implementation in `GetCommitteeReportDto()` requires multiple database queries across both databases, making it inefficient and difficult to maintain.

### Current Data Flow
1. Get base Committee Report data from Eva DB
2. Validate Session, Committee, and Meeting data from Shared DB
3. Fetch removed agenda items from Eva DB
4. Fetch attendance records from a service
5. Fetch agenda items from a service
6. If only published items are requested, apply additional filtering
7. Fetch agenda actions from Eva DB
8. Fetch rollcalls from Eva DB
9. Assemble the complete DTO with data from multiple sources

## Requirements

1. Refactor the Committee Report service to make it more efficient and easier to maintain
2. Make querying for a committee report achievable with fewer database queries
3. Work within the constraints of:
   - Keeping data in their current respective databases
   - Only having control over Eva DB tables and the Committee Report service
   - Not creating database views

## Specific Data Tracking Requirements

Eva DB needs to track:
- Which agenda items have been removed from a report
- Which agenda items have been published in a report
- Which actions for each agenda item have been published

## Proposed Refactoring Solution

### 1. Create Streamlined Tracking Tables in Eva DB

```csharp
// Streamlined agenda item state tracking
public class AgendaItemState
{
    public int Id { get; set; }
    public int MeetingId { get; set; }
    public int AgendaItemId { get; set; } // References Shared DB
    public bool IsPublished { get; set; }
    public bool IsRemoved { get; set; }
}

// Streamlined action state tracking
public class AgendaItemActionState
{
    public int Id { get; set; }
    public int MeetingId { get; set; }
    public int AgendaItemId { get; set; }
    public int ActionId { get; set; } // References action in Eva or Shared DB
    public bool IsPublished { get; set; }
}
```

### 2. Implement an Optimized Repository Pattern

Create a repository that efficiently queries both databases while minimizing round trips:

```csharp
public class CommitteeReportRepository
{
    private readonly EvaDbContext _evaDb;
    private readonly SharedDbContext _sharedDb;
    
    // Implementation that optimizes queries across both contexts
}
```

### 3. Optimize Data Retrieval with Batch Operations

```csharp
public CommitteeReportDto GetCommitteeReportDto(int sessionId, int committeeId, int meetingId, bool onlyPublished)
{
    // Step 1: Get all necessary metadata in parallel queries
    var reportTask = _evaDb.CommitteeReports.FindAsync(/* params */);
    var committeeTask = _sharedDb.Committee.FindAsync(/* params */);
    var meetingTask = _sharedDb.CommitteeMeeting.FindAsync(/* params */);
    
    // Step 2: Get all tracking data in a single query
    var trackingData = _evaDb.AgendaItemStates
        .Where(s => s.MeetingId == meetingId)
        .ToDictionary(s => s.AgendaItemId);
    
    // Step 3: Assemble data from both DBs with proper filtering
    // ...
}
```

### 4. Add Proper Indexing for Performance

```csharp
[Index(nameof(MeetingId), nameof(AgendaItemId))]
public class AgendaItemState
{
    // Properties
}

[Index(nameof(MeetingId), nameof(AgendaItemId), nameof(ActionId))]
public class AgendaItemActionState
{
    // Properties
}
```

## Benefits of the Proposed Solution

1. **Reduced Query Complexity**: Optimized queries that fetch data more efficiently
2. **Simplified Schema**: Focused tracking tables that only store what's needed
3. **Clear Responsibilities**: Separation between data storage and state tracking
4. **Maintainability**: Easier to understand and modify the code
5. **Performance**: Reduced database round trips and better use of indexing
6. **No Data Duplication**: Avoids the need to synchronize duplicated data

This approach provides the simplest effective solution given the constraints of not being able to modify the Shared DB schema or create database views, while still improving the performance and maintainability of the Committee Report service.


proposal 2:
# Revised Committee Report Refactoring Proposal

## Current Situation

The application currently consists of two databases:
- **Shared DB**: Contains core data models including Committee, CommitteeMeeting, CommitteeMeetingAgendaItem, and related entities
- **Eva DB**: Contains Committee Report data and related tracking information

The Committee Report service needs to obtain data from both databases to build a complete report. The current implementation in `GetCommitteeReportDto()` requires multiple database queries across both databases, making it inefficient and difficult to maintain.

### Current Data Flow
1. Get base Committee Report data from Eva DB
2. Validate Session, Committee, and Meeting data from Shared DB
3. Fetch removed agenda items from Eva DB
4. Fetch attendance records from a service
5. Fetch agenda items from a service
6. If only published items are requested, apply additional filtering
7. Fetch agenda actions from Eva DB
8. Fetch rollcalls from Eva DB
9. Assemble the complete DTO with data from multiple sources

## Requirements

1. Refactor the Committee Report service to make it more efficient and easier to maintain
2. Make querying for a committee report achievable with fewer database queries
3. Keep all data in Eva DB for the reports
4. Accommodate the fact that committee, meeting, and agenda item data can be updated via the Eva app but is stored in Shared DB

## Specific Data Tracking Requirements

Eva DB needs to track:
- Complete copies of Committee, Meeting, and Agenda Item data for reports
- Which agenda items have been removed from a report
- Which agenda items have been published in a report
- Which actions for each agenda item have been published
- Synchronization state between Eva and Shared databases

## Revised Refactoring Solution

### 1. Create Comprehensive Models in Eva DB

```csharp
// Complete Committee Report data in Eva DB
public class CommitteeReport
{
    public int Id { get; set; }
    public int SessionId { get; set; }
    public int CommitteeId { get; set; }  // References Shared DB
    public int MeetingId { get; set; }    // References Shared DB
    
    // Committee metadata (copy from Shared DB)
    public string CommitteeName { get; set; }
    
    // Meeting metadata (copy from Shared DB)
    public DateTime MeetingDate { get; set; }
    public string MeetingTime { get; set; }
    public string MeetingLocation { get; set; }
    
    // Report status
    public bool IsPublished { get; set; }
    public DateTime? PublishedDate { get; set; }
    public string PublishedBy { get; set; }
    public bool IsAttendancePublished { get; set; }
    public DateTime? AttendancePublishedDate { get; set; }
    
    // Sync status
    public DateTime LastSyncedWithShared { get; set; }
    public bool IsSyncRequired { get; set; }
    
    // Navigation properties
    public virtual ICollection<CommitteeReportAgendaItem> AgendaItems { get; set; }
    public virtual ICollection<CommitteeReportAttendance> AttendanceRecords { get; set; }
    public virtual ICollection<CommitteeReportJointCommittee> JointCommittees { get; set; }
}

// Agenda Item data
public class CommitteeReportAgendaItem
{
    public int Id { get; set; }
    public int ReportId { get; set; }
    public int? OriginalAgendaItemId { get; set; }  // References Shared DB if exists
    
    // Agenda Item metadata (copy from Shared DB)
    public string Prefix { get; set; }
    public string Identifier { get; set; }
    public string Description { get; set; }
    public int SortOrder { get; set; }
    
    // Status tracking
    public bool IsPublished { get; set; }
    public bool IsRemoved { get; set; }
    
    // Navigation properties
    public virtual CommitteeReport Report { get; set; }
    public virtual ICollection<CommitteeReportAction> Actions { get; set; }
    public virtual ICollection<CommitteeReportRollCall> RollCalls { get; set; }
}

// Models for actions, roll calls, joint committees, etc.
public class CommitteeReportAction
{
    public int Id { get; set; }
    public int AgendaItemId { get; set; }
    public string ActionText { get; set; }
    public bool IsPublished { get; set; }
    
    public virtual CommitteeReportAgendaItem AgendaItem { get; set; }
}

public class CommitteeReportRollCall
{
    public int Id { get; set; }
    public int AgendaItemId { get; set; }
    public string Motion { get; set; }
    public int YesVotes { get; set; }
    public int NoVotes { get; set; }
    
    public virtual CommitteeReportAgendaItem AgendaItem { get; set; }
    public virtual ICollection<CommitteeReportVote> Votes { get; set; }
}

public class CommitteeReportAttendance
{
    public int Id { get; set; }
    public int ReportId { get; set; }
    public int MemberId { get; set; }
    public bool IsPresent { get; set; }
    public string Status { get; set; }
    
    public virtual CommitteeReport Report { get; set; }
}

public class CommitteeReportJointCommittee
{
    public int Id { get; set; }
    public int ReportId { get; set; }
    public int JointCommitteeId { get; set; }
    public string JointCommitteeName { get; set; }
    
    public virtual CommitteeReport Report { get; set; }
}
```

### 2. Implement Synchronization Service

```csharp
public class CommitteeReportSyncService
{
    private readonly EvaDbContext _evaDb;
    private readonly SharedDbContext _sharedDb;
    
    public CommitteeReportSyncService(EvaDbContext evaDb, SharedDbContext sharedDb)
    {
        _evaDb = evaDb;
        _sharedDb = sharedDb;
    }
    
    // Synchronize from Shared DB to Eva DB
    public async Task SyncFromShared(int sessionId, int committeeId, int meetingId)
    {
        // Get data from Shared DB
        var committee = await _sharedDb.Committee.FindAsync(committeeId);
        var meeting = await _sharedDb.CommitteeMeeting.FindAsync(meetingId);
        var agendaItems = await _sharedDb.CommitteeMeetingAgendaItem
            .Where(ai => ai.CommitteeMeetingId == meetingId)
            .ToListAsync();
            
        // Get or create report in Eva DB
        var report = await _evaDb.CommitteeReports
            .FirstOrDefaultAsync(d => 
                d.SessionId == sessionId && 
                d.CommitteeId == committeeId && 
                d.MeetingId == meetingId);
                
        if (report == null)
        {
            // Create new report
            report = new CommitteeReport
            {
                SessionId = sessionId,
                CommitteeId = committeeId,
                MeetingId = meetingId,
                // Initialize with data from Shared DB
                CommitteeName = committee.CommitteeName,
                MeetingDate = meeting.MeetingDate,
                MeetingTime = meeting.MeetingTime,
                MeetingLocation = meeting.MeetingLocation,
                LastSyncedWithShared = DateTime.UtcNow,
                IsSyncRequired = false,
                AgendaItems = new List<CommitteeReportAgendaItem>(),
                AttendanceRecords = new List<CommitteeReportAttendance>(),
                JointCommittees = new List<CommitteeReportJointCommittee>()
            };
            
            _evaDb.CommitteeReports.Add(report);
        }
        else
        {
            // Update existing report with latest Shared DB data
            // Only update if not published
            if (!report.IsPublished)
            {
                report.CommitteeName = committee.CommitteeName;
                report.MeetingDate = meeting.MeetingDate;
                report.MeetingTime = meeting.MeetingTime;
                report.MeetingLocation = meeting.MeetingLocation;
            }
            
            report.LastSyncedWithShared = DateTime.UtcNow;
            report.IsSyncRequired = false;
        }
        
        // Sync agenda items
        await SyncAgendaItems(report, agendaItems);
        
        // Sync other related data...
        
        await _evaDb.SaveChangesAsync();
    }
    
    private async Task SyncAgendaItems(CommitteeReport report, List<CommitteeMeetingAgendaItem> sharedAgendaItems)
    {
        // If report is published, we don't update agenda items
        if (report.IsPublished)
            return;
            
        // Get existing agenda items
        var existingItems = await _evaDb.CommitteeReportAgendaItems
            .Where(ai => ai.ReportId == report.Id)
            .ToListAsync();
            
        // Add new items
        foreach (var sharedItem in sharedAgendaItems)
        {
            var existingItem = existingItems.FirstOrDefault(ei => 
                ei.OriginalAgendaItemId == sharedItem.Id);
                
            if (existingItem == null)
            {
                // Add new item
                _evaDb.CommitteeReportAgendaItems.Add(new CommitteeReportAgendaItem
                {
                    ReportId = report.Id,
                    OriginalAgendaItemId = sharedItem.Id,
                    Prefix = sharedItem.Prefix,
                    Identifier = sharedItem.Identifier,
                    Description = sharedItem.Description,
                    SortOrder = sharedItem.SortOrder,
                    IsPublished = false,
                    IsRemoved = false
                });
            }
            else if (!existingItem.IsRemoved)
            {
                // Update existing item if not manually removed
                existingItem.Prefix = sharedItem.Prefix;
                existingItem.Identifier = sharedItem.Identifier;
                existingItem.Description = sharedItem.Description;
                existingItem.SortOrder = sharedItem.SortOrder;
            }
        }
        
        // Mark items as removed if they no longer exist in Shared DB
        foreach (var existingItem in existingItems)
        {
            if (existingItem.OriginalAgendaItemId.HasValue && 
                !sharedAgendaItems.Any(si => si.Id == existingItem.OriginalAgendaItemId.Value))
            {
                // Only mark as removed if not already removed
                if (!existingItem.IsRemoved)
                {
                    existingItem.IsRemoved = true;
                }
            }
        }
    }
}
```

### 3. Create Repository for Efficient Data Access

```csharp
public class CommitteeReportRepository
{
    private readonly EvaDbContext _evaDb;
    private readonly SharedDbContext _sharedDb;
    private readonly CommitteeReportSyncService _syncService;
    
    public CommitteeReportRepository(
        EvaDbContext evaDb, 
        SharedDbContext sharedDb,
        CommitteeReportSyncService syncService)
    {
        _evaDb = evaDb;
        _sharedDb = sharedDb;
        _syncService = syncService;
    }
    
    public async Task<CommitteeReportDto> GetCommitteeReportDto(int sessionId, int committeeId, int meetingId, bool onlyPublished)
    {
        // Check if sync is needed first
        await EnsureSynchronized(sessionId, committeeId, meetingId);
        
        // Get data directly from Eva DB tables
        var report = await _evaDb.CommitteeReports
            .Include(d => d.AgendaItems.Where(ai => !ai.IsRemoved && (!onlyPublished || ai.IsPublished)))
                .ThenInclude(ai => ai.Actions.Where(a => !onlyPublished || a.IsPublished))
            .Include(d => d.AgendaItems.Where(ai => !ai.IsRemoved && (!onlyPublished || ai.IsPublished)))
                .ThenInclude(ai => ai.RollCalls)
            .Include(d => d.AttendanceRecords)
            .Include(d => d.JointCommittees)
            .FirstOrDefaultAsync(d => 
                d.SessionId == sessionId && 
                d.CommitteeId == committeeId && 
                d.MeetingId == meetingId);
                
        if (report == null)
            return null;
            
        // Map to DTO
        return MapToDto(report, onlyPublished);
    }
    
    private async Task EnsureSynchronized(int sessionId, int committeeId, int meetingId)
    {
        var report = await _evaDb.CommitteeReports
            .FirstOrDefaultAsync(d => 
                d.SessionId == sessionId && 
                d.CommitteeId == committeeId && 
                d.MeetingId == meetingId);
                
        // If no report exists or sync is required, sync from Shared DB
        if (report == null || report.IsSyncRequired || 
            (DateTime.UtcNow - report.LastSyncedWithShared).TotalHours > 1)
        {
            await _syncService.SyncFromShared(sessionId, committeeId, meetingId);
        }
    }
    
    private CommitteeReportDto MapToDto(CommitteeReport report, bool onlyPublished)
    {
        return new CommitteeReportDto
        {
            SessionId = report.SessionId,
            CommitteeId = report.CommitteeId,
            MeetingId = report.MeetingId,
            CommitteeName = report.CommitteeName,
            MeetingDate = report.MeetingDate,
            MeetingTime = report.MeetingTime,
            MeetingLocation = report.MeetingLocation,
            IsPublished = report.IsPublished,
            PublishedDate = report.PublishedDate,
            PublishedBy = report.PublishedBy,
            
            AgendaItems = report.AgendaItems
                .Where(ai => !ai.IsRemoved && (!onlyPublished || ai.IsPublished))
                .OrderBy(ai => ai.SortOrder)
                .Select(ai => new AgendaItemDto
                {
                    Id = ai.Id,
                    OriginalAgendaItemId = ai.OriginalAgendaItemId,
                    Prefix = ai.Prefix,
                    Identifier = ai.Identifier,
                    Description = ai.Description,
                    IsPublished = ai.IsPublished,
                    
                    Actions = ai.Actions
                        .Where(a => !onlyPublished || a.IsPublished)
                        .Select(a => new ActionDto
                        {
                            Id = a.Id,
                            ActionText = a.ActionText,
                            IsPublished = a.IsPublished
                        })
                        .ToList(),
                        
                    RollCalls = ai.RollCalls
                        .Select(rc => new RollCallDto
                        {
                            Id = rc.Id,
                            Motion = rc.Motion,
                            YesVotes = rc.YesVotes,
                            NoVotes = rc.NoVotes
                        })
                        .ToList()
                })
                .ToList(),
                
            AttendanceRecords = report.AttendanceRecords
                .Select(ar => new AttendanceDto
                {
                    MemberId = ar.MemberId,
                    IsPresent = ar.IsPresent,
                    Status = ar.Status
                })
                .ToList(),
                
            JointCommittees = report.JointCommittees
                .Select(jc => new JointCommitteeDto
                {
                    JointCommitteeId = jc.JointCommitteeId,
                    JointCommitteeName = jc.JointCommitteeName
                })
                .ToList()
        };
    }
}
```

### 4. Add Event Handlers for Change Detection

```csharp
public class CommitteeReportEventHandler
{
    private readonly EvaDbContext _evaDb;
    
    public CommitteeReportEventHandler(EvaDbContext evaDb)
    {
        _evaDb = evaDb;
    }
    
    // Handle events from Eva app changes to committee
    public async Task HandleCommitteeChanged(int committeeId)
    {
        // Mark related reports as needing sync
        var affectedReports = await _evaDb.CommitteeReports
            .Where(d => d.CommitteeId == committeeId && !d.IsPublished)
            .ToListAsync();
            
        foreach (var report in affectedReports)
        {
            report.IsSyncRequired = true;
        }
        
        await _evaDb.SaveChangesAsync();
    }
    
    // Similar handlers for meeting changes, agenda item changes, etc.
    public async Task HandleMeetingChanged(int meetingId)
    {
        var affectedReports = await _evaDb.CommitteeReports
            .Where(d => d.MeetingId == meetingId && !d.IsPublished)
            .ToListAsync();
            
        foreach (var report in affectedReports)
        {
            report.IsSyncRequired = true;
        }
        
        await _evaDb.SaveChangesAsync();
    }
    
    public async Task HandleAgendaItemChanged(int agendaItemId)
    {
        var affectedAgendaItems = await _evaDb.CommitteeReportAgendaItems
            .Include(ai => ai.Report)
            .Where(ai => ai.OriginalAgendaItemId == agendaItemId && !ai.Report.IsPublished)
            .ToListAsync();
            
        foreach (var agendaItem in affectedAgendaItems)
        {
            agendaItem.Report.IsSyncRequired = true;
        }
        
        await _evaDb.SaveChangesAsync();
    }
}
```

### 5. Implement Publishing Service

```csharp
public class CommitteeReportPublishService
{
    private readonly EvaDbContext _evaDb;
    private readonly CommitteeReportSyncService _syncService;
    
    public CommitteeReportPublishService(
        EvaDbContext evaDb,
        CommitteeReportSyncService syncService)
    {
        _evaDb = evaDb;
        _syncService = syncService;
    }
    
    public async Task PublishReport(int sessionId, int committeeId, int meetingId, string publishedBy)
    {
        // Ensure synchronized first
        await _syncService.SyncFromShared(sessionId, committeeId, meetingId);
        
        // Get the report
        var report = await _evaDb.CommitteeReports
            .Include(r => r.AgendaItems)
            .FirstOrDefaultAsync(r => 
                r.SessionId == sessionId && 
                r.CommitteeId == committeeId && 
                r.MeetingId == meetingId);
                
        if (report == null)
            throw new NotFoundException("Committee report not found");
            
        // Update published state
        report.IsPublished = true;
        report.PublishedDate = DateTime.UtcNow;
        report.PublishedBy = publishedBy;
        
        // Mark all agenda items as published
        foreach (var item in report.AgendaItems.Where(ai => !ai.IsRemoved))
        {
            item.IsPublished = true;
            
            // Also get and publish all actions
            var actions = await _evaDb.CommitteeReportActions
                .Where(a => a.AgendaItemId == item.Id)
                .ToListAsync();
                
            foreach (var action in actions)
            {
                action.IsPublished = true;
            }
        }
        
        await _evaDb.SaveChangesAsync();
    }
    
    public async Task PublishAttendance(int sessionId, int committeeId, int meetingId, string publishedBy)
    {
        var report = await _evaDb.CommitteeReports
            .FirstOrDefaultAsync(r => 
                r.SessionId == sessionId && 
                r.CommitteeId == committeeId && 
                r.MeetingId == meetingId);
                
        if (report == null)
            throw new NotFoundException("Committee report not found");
            
        report.IsAttendancePublished = true;
        report.AttendancePublishedDate = DateTime.UtcNow;
        
        await _evaDb.SaveChangesAsync();
    }
}
```

## Benefits of the Revised Solution

1. **Single Source of Truth**: Eva DB contains all report data, eliminating cross-database queries
2. **Clear Data Model**: Clean models in Eva DB that mirror the structure needed for reporting
3. **Efficient Queries**: All data for reports comes from a single database
4. **Change Management**: Changes made in Shared DB are identified and synchronized when needed
5. **Reduced Complexity**: Business logic works with a single consistent data model
6. **Performance**: Minimal database round trips during normal operations
7. **Simplified Publishing**: No need to synchronize back to Shared DB upon publishing

## Implementation Considerations

1. **Initial Synchronization**: First-time access to a report will require syncing from Shared DB
2. **Change Detection**: Need mechanisms to detect changes in Shared DB that affect reports
3. **Data Volume**: Assessment of storage requirements for duplicate data
4. **Sync Frequency**: Determine how often to check for updates from Shared DB

This revised solution focuses on keeping all report data in Eva DB while maintaining proper synchronization with the data in Shared DB. It eliminates the concept of drafts and treats all reports as persistent records in Eva DB that can be published when ready.


---- 
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace EvaAPI.Migrations
{
    /// <inheritdoc />
    public partial class CommitteeReportRefactor : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "CommitteeMemberRollCalls");

            migrationBuilder.DropTable(
                name: "CommitteeReportCommitteeActionToAgendaItems");

            migrationBuilder.DropTable(
                name: "CommitteeReportPublishedActions");

            migrationBuilder.DropTable(
                name: "CommitteeReportPublishedItems");

            migrationBuilder.DropTable(
                name: "CommitteeReportRemovedAgendaItems");

            migrationBuilder.AddColumn<string>(
                name: "CommitteeName",
                table: "CommitteeReports",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<DateTime>(
                name: "MeetingDate",
                table: "CommitteeReports",
                type: "datetime2",
                nullable: false,
                defaultValue: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));

            migrationBuilder.AddColumn<string>(
                name: "MeetingLocation",
                table: "CommitteeReports",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<string>(
                name: "MeetingTime",
                table: "CommitteeReports",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.CreateTable(
                name: "CommitteeReportAgendaItems",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    ReportId = table.Column<int>(type: "int", nullable: false),
                    OriginalAgendaItemId = table.Column<int>(type: "int", nullable: true),
                    Prefix = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Identifier = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Description = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    SortOrder = table.Column<int>(type: "int", nullable: false),
                    IsPublished = table.Column<bool>(type: "bit", nullable: false),
                    IsRemoved = table.Column<bool>(type: "bit", nullable: false),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Created = table.Column<DateTime>(type: "datetime2", nullable: false),
                    Modified = table.Column<DateTime>(type: "datetime2", nullable: false),
                    ModifiedBy = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CommitteeReportAgendaItems", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CommitteeReportAgendaItems_CommitteeReports_ReportId",
                        column: x => x.ReportId,
                        principalTable: "CommitteeReports",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "CommitteeReportAttendance",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    ReportId = table.Column<int>(type: "int", nullable: false),
                    MemberId = table.Column<int>(type: "int", nullable: false),
                    MemberName = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    AttendanceTypeId = table.Column<int>(type: "int", nullable: false),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Created = table.Column<DateTime>(type: "datetime2", nullable: false),
                    Modified = table.Column<DateTime>(type: "datetime2", nullable: false),
                    ModifiedBy = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CommitteeReportAttendance", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CommitteeReportAttendance_CommitteeReports_ReportId",
                        column: x => x.ReportId,
                        principalTable: "CommitteeReports",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "CommitteeReportJointCommittees",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    ReportId = table.Column<int>(type: "int", nullable: false),
                    JointCommitteeId = table.Column<int>(type: "int", nullable: false),
                    JointCommitteeName = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Created = table.Column<DateTime>(type: "datetime2", nullable: false),
                    Modified = table.Column<DateTime>(type: "datetime2", nullable: false),
                    ModifiedBy = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CommitteeReportJointCommittees", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CommitteeReportJointCommittees_CommitteeReports_ReportId",
                        column: x => x.ReportId,
                        principalTable: "CommitteeReports",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "CommitteeReportActions",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    AgendaItemId = table.Column<int>(type: "int", nullable: false),
                    CommitteeReportAgendaItemActionId = table.Column<int>(type: "int", nullable: true),
                    ActionText = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    ActionSubText = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    IsPublished = table.Column<bool>(type: "bit", nullable: false),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Created = table.Column<DateTime>(type: "datetime2", nullable: false),
                    Modified = table.Column<DateTime>(type: "datetime2", nullable: false),
                    ModifiedBy = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CommitteeReportActions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CommitteeReportActions_CommitteeReportAgendaItems_AgendaItemId",
                        column: x => x.AgendaItemId,
                        principalTable: "CommitteeReportAgendaItems",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_CommitteeReportActions_CommitteeReportCommitteeActions_CommitteeReportAgendaItemActionId",
                        column: x => x.CommitteeReportAgendaItemActionId,
                        principalTable: "CommitteeReportCommitteeActions",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateTable(
                name: "CommitteeReportRollCalls",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    SessionId = table.Column<int>(type: "int", nullable: false),
                    CommitteeId = table.Column<int>(type: "int", nullable: false),
                    MeetingId = table.Column<int>(type: "int", nullable: false),
                    MemberId = table.Column<int>(type: "int", nullable: false),
                    MemberName = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    AgendaItemId = table.Column<int>(type: "int", nullable: false),
                    RollCallVote = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    PublishedDate = table.Column<DateTime>(type: "datetime2", nullable: true),
                    AddendaDate = table.Column<DateTime>(type: "datetime2", nullable: true),
                    PublishedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    CommitteeReportAgendaItemId = table.Column<int>(type: "int", nullable: true),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Created = table.Column<DateTime>(type: "datetime2", nullable: false),
                    Modified = table.Column<DateTime>(type: "datetime2", nullable: false),
                    ModifiedBy = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CommitteeReportRollCalls", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CommitteeReportRollCalls_CommitteeReportAgendaItems_CommitteeReportAgendaItemId",
                        column: x => x.CommitteeReportAgendaItemId,
                        principalTable: "CommitteeReportAgendaItems",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateIndex(
                name: "IX_CommitteeReportActions_AgendaItemId",
                table: "CommitteeReportActions",
                column: "AgendaItemId");

            migrationBuilder.CreateIndex(
                name: "IX_CommitteeReportActions_CommitteeReportAgendaItemActionId",
                table: "CommitteeReportActions",
                column: "CommitteeReportAgendaItemActionId");

            migrationBuilder.CreateIndex(
                name: "IX_CommitteeReportAgendaItems_ReportId",
                table: "CommitteeReportAgendaItems",
                column: "ReportId");

            migrationBuilder.CreateIndex(
                name: "IX_CommitteeReportAttendance_ReportId",
                table: "CommitteeReportAttendance",
                column: "ReportId");

            migrationBuilder.CreateIndex(
                name: "IX_CommitteeReportJointCommittees_ReportId",
                table: "CommitteeReportJointCommittees",
                column: "ReportId");

            migrationBuilder.CreateIndex(
                name: "IX_CommitteeReportRollCalls_CommitteeReportAgendaItemId",
                table: "CommitteeReportRollCalls",
                column: "CommitteeReportAgendaItemId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "CommitteeReportActions");

            migrationBuilder.DropTable(
                name: "CommitteeReportAttendance");

            migrationBuilder.DropTable(
                name: "CommitteeReportJointCommittees");

            migrationBuilder.DropTable(
                name: "CommitteeReportRollCalls");

            migrationBuilder.DropTable(
                name: "CommitteeReportAgendaItems");

            migrationBuilder.DropColumn(
                name: "CommitteeName",
                table: "CommitteeReports");

            migrationBuilder.DropColumn(
                name: "MeetingDate",
                table: "CommitteeReports");

            migrationBuilder.DropColumn(
                name: "MeetingLocation",
                table: "CommitteeReports");

            migrationBuilder.DropColumn(
                name: "MeetingTime",
                table: "CommitteeReports");

            migrationBuilder.CreateTable(
                name: "CommitteeMemberRollCalls",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    AddendaDate = table.Column<DateTime>(type: "datetime2", nullable: true),
                    AgendaItemId = table.Column<int>(type: "int", nullable: false),
                    CommitteeId = table.Column<int>(type: "int", nullable: false),
                    Created = table.Column<DateTime>(type: "datetime2", nullable: false),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    MeetingId = table.Column<int>(type: "int", nullable: false),
                    MemberId = table.Column<int>(type: "int", nullable: false),
                    Modified = table.Column<DateTime>(type: "datetime2", nullable: false),
                    ModifiedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    PublishedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    PublishedDate = table.Column<DateTime>(type: "datetime2", nullable: true),
                    RoleCallVote = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    SessionId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CommitteeMemberRollCalls", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "CommitteeReportCommitteeActionToAgendaItems",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    CommitteeReportCommitteeActionId = table.Column<int>(type: "int", nullable: true),
                    AgendaItemId = table.Column<int>(type: "int", nullable: false),
                    CustomRecommendedAction = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    CustomReportOutAction = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    MeetingId = table.Column<int>(type: "int", nullable: false),
                    SortOrder = table.Column<int>(type: "int", nullable: false),
                    Sub = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CommitteeReportCommitteeActionToAgendaItems", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CommitteeReportCommitteeActionToAgendaItems_CommitteeReportCommitteeActions_CommitteeReportCommitteeActionId",
                        column: x => x.CommitteeReportCommitteeActionId,
                        principalTable: "CommitteeReportCommitteeActions",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateTable(
                name: "CommitteeReportPublishedActions",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    CommitteeReportCommitteeActionId = table.Column<int>(type: "int", nullable: true),
                    AgendaItemId = table.Column<int>(type: "int", nullable: false),
                    CustomRecommendedAction = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    CustomReportOutAction = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    MeetingId = table.Column<int>(type: "int", nullable: false),
                    SortOrder = table.Column<int>(type: "int", nullable: false),
                    Sub = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CommitteeReportPublishedActions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_CommitteeReportPublishedActions_CommitteeReportCommitteeActions_CommitteeReportCommitteeActionId",
                        column: x => x.CommitteeReportCommitteeActionId,
                        principalTable: "CommitteeReportCommitteeActions",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateTable(
                name: "CommitteeReportPublishedItems",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    AgendaItemId = table.Column<int>(type: "int", nullable: false),
                    Created = table.Column<DateTime>(type: "datetime2", nullable: false),
                    CreatedBy = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    MeetingId = table.Column<int>(type: "int", nullable: false),
                    Modified = table.Column<DateTime>(type: "datetime2", nullable: false),
                    ModifiedBy = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CommitteeReportPublishedItems", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "CommitteeReportRemovedAgendaItems",
                columns: table => new
                {
                    MeetingId = table.Column<int>(type: "int", nullable: false),
                    AgendaItemId = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_CommitteeReportRemovedAgendaItems", x => new { x.MeetingId, x.AgendaItemId });
                });

            migrationBuilder.CreateIndex(
                name: "IX_CommitteeReportCommitteeActionToAgendaItems_CommitteeReportCommitteeActionId",
                table: "CommitteeReportCommitteeActionToAgendaItems",
                column: "CommitteeReportCommitteeActionId");

            migrationBuilder.CreateIndex(
                name: "IX_CommitteeReportPublishedActions_CommitteeReportCommitteeActionId",
                table: "CommitteeReportPublishedActions",
                column: "CommitteeReportCommitteeActionId");
        }
    }
}

old tables from eva db

using EvaAPI.Data.Common;

namespace EvaAPI.Data.Models.Committees
{
    public class CommitteeReport : TrackableEntity
    {
        public int SessionId { get; set; }
        public int CommitteeId { get; set; }
        public int MeetingId { get; set; }
        public bool IsPublished { get; set; }
        public DateTime? PublishedDate { get; set; }
        public DateTime? AddendaDate { get; set; }
        public string PublishedBy { get; set; }
        public string AttendancePublishedBy { get; set; }
        public bool IsAttendancePublished { get; set; }
        public byte[] PublishedReportDocument { get; set; }
        public byte[] PublishedAttendanceReportDocument { get; set; }
        public DateTime? AttendancePublishedDate { get; set; }
    }
}


using EvaAPI.Data.Common;

namespace EvaAPI.Data.Models.Reports
{
    public class CommitteeMemberRollCall : TrackableEntity
    {
        public int SessionId { get; set; }
        public int CommitteeId { get; set; }
        public int MeetingId { get; set; }
        public int MemberId { get; set; }
        public int AgendaItemId { get; set; }
        public string RoleCallVote { get; set; }
        public DateTime? PublishedDate { get; set; }
        public DateTime? AddendaDate { get; set; }
        public string PublishedBy { get; set; }
    }
}


namespace EvaAPI.Data.Models.Committees
{
    public class CommitteeReportCommitteeActionToAgendaItem
    {
        public int Id { get; set; }
        public int MeetingId { get; set; }
        public int AgendaItemId { get; set; }
        public string Sub { get; set; }
        public int SortOrder { get; set; }
        public int? CommitteeReportCommitteeActionId { get; set; }
        public string CustomReportOutAction { get; set; }
        public string CustomRecommendedAction { get; set; }
        public virtual CommitteeReportCommitteeAction CommitteeReportCommitteeAction { get; set; }
    }
}


namespace EvaAPI.Data.Models.Committees
{
    public class CommitteeReportPublishedActions 
    {
        public int Id { get; set; }
        public int MeetingId { get; set; }
        public int AgendaItemId { get; set; }
        public string Sub { get; set; }
        public int SortOrder { get; set; }
        public int? CommitteeReportCommitteeActionId { get; set; }
        public string CustomReportOutAction { get; set; }
        public string CustomRecommendedAction { get; set; }
        public virtual CommitteeReportCommitteeAction CommitteeReportCommitteeAction { get; set; }
    }
}


using EvaAPI.Data.Common;

namespace EvaAPI.Data.Models.Committees
{
    public class CommitteeReportPublishedItems : TrackableEntity
    {
        public int MeetingId { get; set; }
        public int AgendaItemId { get; set; }
    }
}

using System.Security.Cryptography.Pkcs;

namespace EvaAPI.Data.Models.Committees
{
    public class CommitteeReportRemovedAgendaItem
    {
        public int MeetingId { get; set; }
        public int AgendaItemId { get; set; }
    }
}

tables from shared db
using EvaAPI.Data.Interfaces;
using EvaAPI.Data.M2.Models.Locations;
using System.ComponentModel.DataAnnotations.Schema;

namespace EvaAPI.Data.M2.Models.Committees
{
    public class CommitteeMeeting : IAddedDate, IModifiedInfo
    {
        [Column("CommitteeMeetingID")]
        public int Id { get; set; }
        public int SessionId { get; set; }
        public int ChamberId { get; set; }
        public DateTime MeetingDate { get; set; }
        public string MeetingTime { get; set; }
        public string MeetingLocation { get; set; }
        public int? LocationId { get; set; }
        public string MeetingNotes { get; set; }
        public int? MeetingStatusTypeID { get; set; }
        public bool IsPublished { get; set; }
        public DateTime? DatePublished { get; set; }
        public int? ChairId { get; set; }
        public string ChairCode { get; set; }
        public int? ClerkId { get; set; }
        public bool IsJointCommittee { get; set; }
        public int SameDaySortOrder { get; set; }
        public bool IsAfterSession { get; set; }
        public bool AOBLanguageUsed { get; set; }
        public bool IsPublic { get; set; }
        public bool IsEditing { get; set; }
        public DateTime DateAdded { get; set; }
        public DateTime LastModified { get; set; }
        public string LastModifiedBy { get; set; }
        public bool IsActive { get; set; }
        public virtual Location Location { get; set; }
        public virtual UserProfile Clerk { get; set; }
        public virtual ICollection<CommitteeMeetingCommittee> CommitteeMeetingCommittee { get; set; }
        public virtual ICollection<CommitteeMeetingAgendaItem> CommitteeMeetingAgendaItems { get; set; }
    }
}
using EvaAPI.Data.M2.Models.Locations;
using System.ComponentModel.DataAnnotations.Schema;

namespace EvaAPI.Data.M2.Models.Committees
{
    public class Committee : IModifiedInfo, IAddedDate
    {
        [Column("CommitteeID")]
        public int Id { get; set; }
        public int CommitteeTypeId { get; set; }
        public int SessionId { get; set; }
        public int ChamberId { get; set; }
        public int? ChairId { get; set; }
        public int? ClerkId { get; set; }
        public int? LocationId { get; set; }
        public string CommitteePhone { get; set; }
        public string CommitteeName { get; set; }
        public string IntegrationName { get; set; }
        public string NameCode { get; set; }
        public bool IsAfterSession { get; set; }
        public bool IsActive { get; set; }
        public bool IsPublic { get; set; }
        public int? CommitteeParentId { get; set; }
        public string MeetingDay { get; set; }
        public string MeetingTime { get; set; }
        public DateTime DateAdded { get; set; }
        public DateTime LastModified { get; set; }
        public string LastModifiedBy { get; set; }
        public string Website { get; set; }
        public int? ListServId { get; set; }
        public virtual CommitteeType CommitteeType { get; set; }
        public virtual ListServ ListServ { get; set; }
        [ForeignKey(nameof(CommitteeParentId))]
        public virtual Committee ParentCommittee { get; set; }
        public virtual ICollection<CommitteeMember> Members { get; set; }
        public virtual Location Location { get; set; }
        
    }
}
using System.ComponentModel.DataAnnotations.Schema;

namespace EvaAPI.Data.M2.Models.Committees
{
    public class CommitteeMeetingAgendaItem : IAddedDate, IModifiedInfo
    {
        [Column("CommitteeMeetingAgendaItemID")]
        public int Id { get; set; }
        public int SessionId { get; set; }
        public int CommitteeMeetingId { get; set; }
        public int? LegislationId { get; set; }
        public int SortOrder { get; set; }
        public string Description { get; set; }
        public DateTime DateAdded { get; set; }
        public DateTime LastModified { get; set; }
        public string LastModifiedBy { get; set; }
        public bool IsPublic { get; set; }
        public bool IsActive { get; set; }
        public virtual CommitteeMeeting CommitteeMeeting { get; set; }
        public virtual Legislation.Legislation Legislation { get; set; }
    }
}
using System.ComponentModel.DataAnnotations.Schema;

namespace EvaAPI.Data.M2.Models.Committees
{
    public class CommitteeMeetingAttendanceRecord : IAddedDate, IModifiedInfo
    {
        [Column("CommitteeMeetingAttendanceRecordID")]
        public int Id { get; set; }
        public int ChamberId { get; set; }
        public int CommitteeMeetingId { get; set; }
        public int SessionId { get; set; }
        public int CommitteeMemberId { get; set; }
        public int AttendanceTypeId { get; set; }
        public DateTime DateAdded { get; set; }
        public DateTime LastModified { get; set; }
        public string LastModifiedBy { get; set; }
        public bool IsActive { get; set; }
        public virtual CommitteeMember CommitteeMember { get; set; }
        public virtual AttendanceType AttendanceType { get; set; }
    }
}
using System.ComponentModel.DataAnnotations.Schema;

namespace EvaAPI.Data.M2.Models.Committees
{
    public class CommitteeMeetingCommittee : IModifiedInfo, IAddedDate
    {
        [Column("CommitteeMeetingCommitteeID")]
        public int Id { get; set; }
        public int CommitteeMeetingId { get; set; }
        public int CommitteeId { get; set; }
        public bool IsPrimary { get; set; }
        public bool IsActive { get; set; }
        public int SortOrder { get; set; }
        public DateTime DateAdded { get; set; }
        public DateTime LastModified { get; set; }
        public string LastModifiedBy { get; set; }
        public virtual CommitteeMeeting CommitteeMeeting { get; set; }
        public virtual Committee Committee { get; set; }
    }
}
using EvaAPI.Data.Interfaces;
using EvaAPI.Data.M2.Models.Legislation;
using System.ComponentModel.DataAnnotations.Schema;

namespace EvaAPI.Data.M2.Models.Committees
{
    public class CommitteeMember
    {
        [Column("CommitteeMemberID")]
        public int Id { get; set; }
        public int CommitteeId { get; set; }
        public int CommitteeRoleId { get; set; }
        public int SessionId { get; set; }
        public int ChamberId { get; set; }
        public int? LegislatorId { get; set; }
        public int PersonId { get; set; }
        public int SortOrder { get; set; }
        public bool IsActive { get; set; }
        public virtual Legislator Legislator { get; set; }
        public virtual UserProfile Person { get; set; }
        public virtual CommitteeRole CommitteeRole { get; set; }
    }
}





-----
Create a python script

the script will be ran before the migration in the paasted context

the script should create a dataset, in json, that will be in a format that makes sense for the new schema. I will use this script as a way to sort of 'back up' all the data that I need.

After I run this script to get all the relevant data for this schema migration.

I will run the actual migration

I will then use another script/the same script but with different parameters, to use the previous output, and align the data into the new schema.

The purpose of all of this is to prevent data loss. I am dropping many tables as you can see in the migration. I don't want to lose any of that data. I am also adding several columns and tables as navigation properties to the Committee Reports table. I will need to populate all of these based on the existing data.

Full routine for this will be 

run pre deployment data gathering script

deploy + migrate db

run data restoring script

these scripts should be in python

they should connect to each database, shared and eva

they should correctly query the data needed

they should correctly organize the data into the proper shapes

they should log all relevent steps 

they should be written in a way that is easily iterated on by llms

they should contain no comments.

I want you to generate the first step for this script , run pre deployment data gathering script

then explain to me how it works and any pit falls you see with it 

----
Okay, let's architect an opinionated approach to refactor your Committee Reports feature, focusing on component responsibility, data flow, and form management.

**Core Philosophy:**

* **Component Responsibility:** Break down the UI into smaller, focused components. Each component should do one thing well.
* **Clear Data Flow:** Prefer `@Input` for passing data down and `@Output` or service calls for sending changes/events up. Avoid complex inter-component dependencies.
* **Reactive Forms per Item:** Manage forms for dynamic lists (like actions or roll calls) *within* the component responsible for that specific item.
* **Embrace Auto-Save:** Design components to handle saving their specific piece of data automatically, eliminating the need for a global "Save" button for the agenda section.

**Proposed Component Structure:**

1.  **`committee-reports-container` (Existing):**
    * **Role:** Top-level container, potentially manages tabs, fetches initial committee/meeting context if needed.
    * **Opinion:** Keep it lean. Its main job is layout and hosting the primary "smart" component.

2.  **`committee-reports` (Refactored - Smart Component):**
    * **Role:** Orchestrator. Fetches the main `CommitteeReportDto` data (including the array of `CommitteeReportAgendaItemDto`).
    * **Data Flow:**
        * Fetches `report` data from a service.
        * Passes `report` (or specific parts like `report.meetingDate`, `report.committeeName`, etc.) via `@Input` to `committee-reports-header`.
        * Passes the `report.agendaItems` array via `@Input` to the `agenda-items-list` component.
    * **Opinion:** This component should *not* manage the `FormArray`s for all agenda items anymore. It delegates that responsibility down. It listens for high-level events if necessary (e.g., if a new item is added and the whole list needs a refresh signal).

3.  **`committee-reports-header` (Existing - Presentational Component):**
    * **Role:** Displays report metadata, attendance summary, publish/download buttons.
    * **Data Flow:** Receives all necessary data via `@Input` from `committee-reports`. Emits events (`@Output`) for actions like "publish report", "download preview", etc.
    * **Opinion:** Keep this focused purely on presentation and emitting user actions.

4.  **`agenda-items-list` (New or Heavily Refactored `committee-report-agenda-items`):**
    * **Role:** Manages the *list* of agenda items. Handles adding new items (custom or from legislation search) and removing items.
    * **Data Flow:** Receives `agendaItems: CommitteeReportAgendaItemDto[]` via `@Input`.
    * **Functionality:**
        * Uses `*ngFor` to loop through the `agendaItems` array.
        * For each item in the loop, renders an `agenda-item` component, passing the individual `item` down via `@Input`.
        * Includes the UI for adding new items (like your legislation search and custom input) [cite: uploaded:committee-reports/agenda-items/agenda-items.component.html]. When a new item is added, it likely calls a service to create it on the backend and then updates its list (either via refetching or adding to the local array if the service returns the created item).
        * Handles the removal request for an item (likely by calling a service and updating the list).
    * **HTML Pseudo-code:**
        ```html
        <div *ngFor="let item of agendaItems; trackBy: trackById">
          <app-agenda-item
            [agendaItem]="item"
            (itemRemoved)="requestItemRemoval(item)">
            </app-agenda-item>
        </div>
        ```
    * **TS Pseudo-code:**
        ```typescript
        // agenda-items-list.component.ts
        @Input() agendaItems: CommitteeReportAgendaItemDto[];
        // Inject services for adding/removing items

        trackById(index: number, item: CommitteeReportAgendaItemDto): number | string {
          return item.id || item.description; // Use a unique identifier
        }

        addNewLegislationItem(item: SimpleLegislationDto) {
          // Call service to create the new agenda item on the backend
          // Update this.agendaItems array (e.g., refetch or push new item)
        }

        addCustomItem(description: string) {
          // Call service to create the new custom agenda item
          // Update this.agendaItems array
        }

        requestItemRemoval(itemToRemove: CommitteeReportAgendaItemDto) {
          // Call service to delete the item
          // Update this.agendaItems array (filter out removed item)
        }
        ```

5.  **`agenda-item` (New - Presentational but with Form Logic):**
    * **Role:** Displays *one* agenda item within an expansion panel. Manages the **Reactive Form** for *this specific item's* roll calls and actions. Handles auto-saving its own changes.
    * **Data Flow:** Receives `agendaItem: CommitteeReportAgendaItemDto` via `@Input`. Emits `(itemRemoved)` event via `@Output`.
    * **Functionality:**
        * Uses `MatExpansionPanel` [cite: uploaded:committee-reports/agenda-items/agenda-items.component.html].
        * Creates its own `FormGroup` (e.g., `itemForm`) using `FormBuilder`. This form group contains `FormArray`s for `rollCalls` and `actions`.
        * Populates these `FormArray`s based on the `@Input agendaItem` data in `ngOnInit` or `ngOnChanges`.
        * **Auto-Save:** Subscribes to `itemForm.valueChanges` with operators like `debounceTime` and `distinctUntilChanged`. When changes are detected, it calls a service method to **update just this specific agenda item** (or its roll calls/actions) on the backend.
        * Provides methods to add/remove individual roll call entries or action entries *within its own form*.
    * **HTML Pseudo-code:**
        ```html
        <mat-expansion-panel [formGroup]="itemForm">
          <mat-expansion-panel-header>
             {{ displayItemTitle }}
          </mat-expansion-panel-header>

          <h4>Roll Calls</h4>
          <div formArrayName="rollCalls">
             <div *ngFor="let rcGroup of rollCallsFormArray.controls; let i = index" [formGroupName]="i">
                </div>
             <button (click)="addRollCall()">Add Roll Call</button>
          </div>

          <h4>Actions</h4>
          <div formArrayName="actions">
             <div *ngFor="let actionGroup of actionsFormArray.controls; let i = index" [formGroupName]="i">
                 </div>
             <button (click)="addAction()">Add Action</button>
          </div>

        </mat-expansion-panel>
        <button (click)="emitRemoveRequest()">Remove Item</button>
        ```
    * **TS Pseudo-code:**
        ```typescript
        // agenda-item.component.ts
        @Input() agendaItem: CommitteeReportAgendaItemDto;
        @Output() itemRemoved = new EventEmitter<void>(); // Just signal removal request

        itemForm: FormGroup;
        // Inject FormBuilder, YourApiService

        ngOnInit() {
          this.itemForm = this.fb.group({
            // Maybe ID/Description if needed, but primarily arrays
            rollCalls: this.fb.array([]),
            actions: this.fb.array([])
          });
          this.populateFormArrays();
          this.setupAutoSave();
        }

        get rollCallsFormArray(): FormArray { return this.itemForm.get('rollCalls') as FormArray; }
        get actionsFormArray(): FormArray { return this.itemForm.get('actions') as FormArray; }

        populateFormArrays() {
          this.rollCallsFormArray.clear();
          this.actionsFormArray.clear();
          this.agendaItem.rollCalls?.forEach(rc => this.rollCallsFormArray.push(this.createRollCallGroup(rc)));
          this.agendaItem.actions?.forEach(a => this.actionsFormArray.push(this.createActionGroup(a)));
        }

        createRollCallGroup(rc?: CommitteeReportRollCallDto): FormGroup {
          return this.fb.group({ /* roll call fields based on DTO */ });
        }

        createActionGroup(a?: CommitteeReportActionDto): FormGroup { // Assuming DTO name
          return this.fb.group({ /* action fields based on DTO */ });
        }

        addRollCall() { this.rollCallsFormArray.push(this.createRollCallGroup()); }
        addAction() { this.actionsFormArray.push(this.createActionGroup()); }
        removeRollCall(index: number) { this.rollCallsFormArray.removeAt(index); }
        removeAction(index: number) { this.actionsFormArray.removeAt(index); }


        setupAutoSave() {
          this.itemForm.valueChanges.pipe(
            debounceTime(750), // Adjust as needed
            distinctUntilChanged((prev, curr) => JSON.stringify(prev) === JSON.stringify(curr)), // Basic deep check
            switchMap(formValue => {
              // Map formValue back to the structure needed for update API
              const updatePayload = this.mapFormToUpdatePayload(formValue);
              // Call API to update *this* agenda item
              return this.apiService.updateAgendaItem(this.agendaItem.id, updatePayload);
            }),
            takeUntil(this.destroy$) // Assuming you have a way to unsubscribe
          ).subscribe({
             next: () => console.log('Auto-saved item:', this.agendaItem.id),
             error: (err) => console.error('Auto-save failed:', err) // Add error handling!
          });
        }

        mapFormToUpdatePayload(formValue: any): Partial<CommitteeReportAgendaItemDto> {
           // Convert form arrays back to DTO arrays/structure
           return { rollCalls: formValue.rollCalls, actions: formValue.actions };
        }

        emitRemoveRequest() {
          this.itemRemoved.emit();
        }
        ```

**Benefits of this Approach:**

* **Isolation:** Each `agenda-item` component manages its own state and complexity. Changes to one don't directly affect others.
* **Simpler Forms:** No more managing giant nested `FormArray`s in a parent component. Forms are localized to the data they represent.
* **True Auto-Save:** Saving happens granularly within the `agenda-item` component based on its form changes.
* **Maintainability:** Smaller components with single responsibilities are easier to understand, test, and modify. The old, complex save/update logic in the parent component is eliminated [cite: uploaded:committee-reports.component.ts].
* **Performance:** `trackBy` in the `*ngFor` helps Angular optimize list rendering.

**API Considerations:**

* Your backend needs endpoints to:
    * Fetch the full `CommitteeReportDto`.
    * Create a new `CommitteeReportAgendaItemDto` (custom or based on legislation).
    * **Update a specific `CommitteeReportAgendaItemDto` (likely via PATCH), including its nested roll calls and actions.** This is critical for auto-save.
    * Delete a specific `CommitteeReportAgendaItemDto`.

This refactoring moves complexity down the component tree, localizing form management and enabling a robust auto-save mechanism at the individual agenda item level.

Yes, you absolutely can set this up to avoid using Angular's `FormArray` directly within the `agenda-item` component, although it involves trade-offs.

Here’s an opinionated approach focusing on further componentization:

**Approach: Decompose Further into "Entry" Components**

Instead of having the `agenda-item` component manage `FormArray`s for roll calls and actions, you can break down those lists further.

1.  **`agenda-item` Component:**
    * Still receives the single `agendaItem: CommitteeReportAgendaItemDto` via `@Input`.
    * Does **not** create `FormArray`s.
    * It directly iterates over the `agendaItem.rollCalls` and `agendaItem.actions` data arrays using `*ngFor`.
    * Inside the `*ngFor` loops, it renders dedicated child components for each entry (e.g., `roll-call-entry`, `action-entry`).
    * **Data Flow:** Passes the individual `rollCall` object or `action` object down to the respective entry component via `@Input`.
    * **Change Handling:** Listens for update/delete events (`@Output`) from the child entry components OR relies on the child components calling services directly.

2.  **`roll-call-entry` Component (New):**
    * **Role:** Manages the display and editing of **one single roll call record**.
    * **Data Flow:** Receives `rollCall: CommitteeReportRollCallDto` via `@Input`. Receives `memberInfo` (like name/honorific) maybe via separate `@Input` or looks it up based on `memberId` if needed.
    * **Form:** Creates a *very simple* `FormGroup` for just this one roll call (e.g., just the `vote` control) OR could even use `[(ngModel)]` for the vote selection if preferred.
    * **Auto-Save:** Subscribes to its *own* form's `valueChanges` (or uses `(ngModelChange)`). When the vote changes, it calls the service method to update *this specific roll call record* on the backend, identifying it perhaps by a unique roll call ID or a combination of agenda item ID and member ID.
    * **Deletion:** Has a button that emits an event (`@Output`) or calls a service to delete *this specific roll call record*.

3.  **`action-entry` Component (New):**
    * **Role:** Manages the display and editing of **one single action record**.
    * **Data Flow:** Receives `action: CommitteeReportActionDto` via `@Input`.
    * **Form:** Creates a simple `FormGroup` for this one action (e.g., `actionText`, `actionSubText` controls) OR uses `[(ngModel)]`.
    * **Auto-Save:** Similar to `roll-call-entry`, it subscribes to its own form/model changes and calls a service to update *this specific action record* when changes occur (debounced, etc.).
    * **Deletion:** Has a button to emit/call service to delete *this specific action record*.

**Pseudo-code Illustration:**

```typescript
// agenda-item.component.ts
@Input() agendaItem: CommitteeReportAgendaItemDto;
// No FormArrays here
// Inject service if children don't call it directly

handleRollCallUpdate(updatedRollCall: CommitteeReportRollCallDto) {
  // If child emits, update API via service here
}
handleActionUpdate(updatedAction: CommitteeReportActionDto) {
  // If child emits, update API via service here
}
handleRollCallDelete(rollCallToDelete: CommitteeReportRollCallDto) {
 // Call service, maybe update local agendaItem.rollCalls array
}
handleActionDelete(actionToDelete: CommitteeReportActionDto) {
 // Call service, maybe update local agendaItem.actions array
}

// ---

// roll-call-entry.component.ts
@Input() rollCall: CommitteeReportRollCallDto;
// @Output() rollCallUpdated = new EventEmitter<...>(); // Option 1: Emit
// @Output() rollCallDeleted = new EventEmitter<...>(); // Option 1: Emit
// OR Inject service // Option 2: Direct call

voteControl = new FormControl(); // Or simple FormGroup, or ngModel

ngOnInit() {
  this.voteControl.setValue(this.rollCall.vote); // Assuming structure
  this.voteControl.valueChanges.pipe(
    debounceTime(500),
    distinctUntilChanged(),
    switchMap(newValue =>
      // Option 2: Call service directly to update this specific roll call
      this.apiService.updateRollCall(this.rollCall.id, { vote: newValue })
      // Option 1: Emit the change
      // this.rollCallUpdated.emit({ ...this.rollCall, vote: newValue });
    )
  ).subscribe();
}

deleteThisRollCall() {
  // Option 2: this.apiService.deleteRollCall(this.rollCall.id);
  // Option 1: this.rollCallDeleted.emit(this.rollCall);
}

// --- Action-entry component similar structure ---
```

```html
<mat-expansion-panel>
  <h4>Roll Calls</h4>
  <div *ngFor="let rc of agendaItem.rollCalls; trackBy: trackRollCallById">
    <app-roll-call-entry
      [rollCall]="rc"
      (rollCallUpdated)="handleRollCallUpdate($event)" (rollCallDeleted)="handleRollCallDelete(rc)">    </app-roll-call-entry>
  </div>
  <button (click)="requestAddRollCall()">Add New Roll Call</button> <h4>Actions</h4>
  <div *ngFor="let action of agendaItem.actions; trackBy: trackActionById">
     <app-action-entry
       [action]="action"
       (actionUpdated)="handleActionUpdate($event)" (actionDeleted)="handleActionDelete(action)">   </app-action-entry>
  </div>
  <button (click)="requestAddAction()">Add New Action</button> </mat-expansion-panel>
```

**Trade-offs:**

* **Pros:**
    * Avoids `FormArray` complexity within `agenda-item`.
    * Creates very small, focused components (`roll-call-entry`, `action-entry`) that are easy to test and understand.
    * Auto-save logic is localized to the smallest possible unit.
* **Cons:**
    * More components to create and manage.
    * You lose the built-in benefits of `FormArray` for aggregating values or validity across the list (though maybe not needed if saving happens per entry).
    * Need clear API endpoints to create/update/delete *individual* roll call and action records, identified uniquely (e.g., by their own IDs).
    * Decisions needed on how adding/deleting list items is handled (service calls in the list component vs. parent).

**Opinion:**

This "decomposed entry component" approach is a valid way to avoid `FormArray` if you have a strong reason to. It aligns well with component-based architecture. However, be aware that `FormArray` is the standard Angular Reactive Forms tool for this job, and avoiding it means you might be manually implementing tracking or validation logic that it provides out-of-the-box. If your primary goal was just to move the `FormArray` *out* of the `committee-reports` component, the previous proposal (putting it in `agenda-item`) might still be simpler overall than creating additional layers of components.
