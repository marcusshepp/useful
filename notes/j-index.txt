You are a software engineer at a company that creates software for the US Senate.

you do not comment your code. you write clean code that is self-explanatory.
You prioritize readability and maintainability over cleverness.
and you want to make the most simple solution that works.

you do not write any bugs.
you explicitly type all variables and methods 

I am creating a feature where the user has the 
ability to create an index for a senate journal.

The index is a tree structure where the user can add up to four levels
of terms. Each level can have any number of terms. But each primary node (also a term)
can only be up to four levels deep.

The user can add a term to the index by clicking an "add" button.
The user can delete a term from the index by clicking a "delete" button.
The user can add a page number to a term by clicking an "add page number" button.

I'm using angular for the front end and dotnet ef core for the backend

the tree structure is saved to the db with the following model:
public class IndexTreeNode
{
    public int Id { get; set; }
    public int SessionId { get; set; }
    public string NodeText { get; set; }
    public int PrimaryTermId { get; set; }
    public int? SecondaryTermId { get; set; }
    public int? TertiaryTermId { get; set; }
    public int? QuaternaryTermId { get; set; }
    public virtual IndexTerm PrimaryTerm { get; set; }
    public virtual IndexTerm SecondaryTerm { get; set; }
    public virtual IndexTerm TertiaryTerm { get; set; }
    public virtual IndexTerm QuaternaryTerm { get; set; }
    public string CreatedBy { get; set; }
    public DateTime Created { get; set; }
    public DateTime Modified { get; set; }
    public string ModifiedBy { get; set; }
}

Here is the response object for each node. The api will return a list of these objects.

public class IndexTreeNodeDto
{
    public int Id { get; set; }
    public int TermId { get; set; }
    public string Term { get; set; }
    public List<int> PageNumbers { get; set; }
    public List<IndexTreeNodeDto> ChildNodes { get; set; }
}

each node represents a term. Here is the model for the terms:

public class IndexTerm 
{
    public int Id { get; set; }
    public string Term { get; set; }
    public string CreatedBy { get; set; }
    public DateTime Created { get; set; }
    public DateTime Modified { get; set; }
    public string ModifiedBy { get; set; }
    public bool IsSenator { get; set; }
}

The page numbers for each node are stored in a separate table:
public class IndexTreeNodePageNumber : TrackableEntity
{
    public int? PageNumber { get; set; }
    public int IndexTreeNodeId { get; set; }
    public int SessionId { get; set; }
    public int SessionDayId { get; set; }
    public virtual IndexTreeNode IndexTreeNode { get; set; }
}

here is the code for how i'm building out the tree dtos from the db data:
private List<IndexTreeNodeDto> GetNodeDtoFromQuery(List<IndexTreeNode> nodes)
{
    Dictionary<string, IndexTreeNodeDto> termMap = new Dictionary<string, IndexTreeNodeDto>();
    List<IndexTreeNodeDto> primaries = new List<IndexTreeNodeDto>();

    foreach (IndexTreeNode node in nodes)
    {
        string primaryKey = node.PrimaryTermId.ToString();

        if (!termMap.TryGetValue(primaryKey, out IndexTreeNodeDto primaryNode))
        {
            primaryNode = new IndexTreeNodeDto
            {
                Id = node.Id,
                   TermId = node.PrimaryTermId,
                   Term = node.PrimaryTerm?.Term ?? node.NodeText,
                   ChildNodes = new List<IndexTreeNodeDto>()
            };
            termMap.Add(primaryKey, primaryNode);
            primaries.Add(primaryNode);
        }

        if (string.IsNullOrEmpty(node.SecondaryTerm?.Term) && string.IsNullOrEmpty(node.NodeText))
        {
            continue;
        }

        string secondaryKey = $"{primaryKey}_{node.SecondaryTermId ?? node.Id}";
        if (!termMap.TryGetValue(secondaryKey, out IndexTreeNodeDto secondaryNode))
        {
            secondaryNode = new IndexTreeNodeDto
            {
                Id = node.Id,
                   TermId = node.SecondaryTermId,
                   Term = node.SecondaryTerm?.Term ?? node.NodeText,
                   ChildNodes = new List<IndexTreeNodeDto>()
            };
            termMap.Add(secondaryKey, secondaryNode);
            primaryNode.ChildNodes.Add(secondaryNode);
        }

        if (string.IsNullOrEmpty(node.TertiaryTerm?.Term) && string.IsNullOrEmpty(node.NodeText))
        {
            continue;
        }

        string tertiaryKey = $"{secondaryKey}_{node.TertiaryTermId ?? node.Id}";
        if (!termMap.TryGetValue(tertiaryKey, out IndexTreeNodeDto tertiaryNode))
        {
            tertiaryNode = new IndexTreeNodeDto
            {
                Id = node.Id,
                   TermId = node.TertiaryTermId,
                   Term = node.TertiaryTerm?.Term ?? node.NodeText,
                   ChildNodes = new List<IndexTreeNodeDto>()
            };
            termMap.Add(tertiaryKey, tertiaryNode);
            secondaryNode.ChildNodes.Add(tertiaryNode);
        }

        if (string.IsNullOrEmpty(node.QuaternaryTerm?.Term) && string.IsNullOrEmpty(node.NodeText))
        {
            continue;
        }

        string quaternaryKey = $"{tertiaryKey}_{node.QuaternaryTermId ?? node.Id}";
        if (!termMap.TryGetValue(quaternaryKey, out IndexTreeNodeDto quaternaryNode))
        {
            quaternaryNode = new IndexTreeNodeDto
            {
                Id = node.Id,
                   TermId = node.QuaternaryTermId,
                   Term = node.QuaternaryTerm?.Term ?? node.NodeText,
                   ChildNodes = new List<IndexTreeNodeDto>()
            };
            termMap.Add(quaternaryKey, quaternaryNode);
            tertiaryNode.ChildNodes.Add(quaternaryNode);
        }
    }

    foreach (IndexTreeNodeDto primary in primaries)
    {
        primary.ChildNodes = primary.ChildNodes.OrderBy(x => x.Term).ToList();
        foreach (IndexTreeNodeDto secondary in primary.ChildNodes)
        {
            secondary.ChildNodes = secondary.ChildNodes.OrderBy(x => x.Term).ToList();
            foreach (IndexTreeNodeDto tertiary in secondary.ChildNodes)
            {
                tertiary.ChildNodes = tertiary.ChildNodes.OrderBy(x => x.Term).ToList();
            }
        }
    }

    return primaries.OrderBy(x => x.Term).ToList();
}

public List<IndexTreeNodeDto> GetIndexTreeBySessionDay(int sessionId, int sessionDayId)
{

    List<IndexTreeNodePageNumber> pageNumbersforSessionDay = _evaDbContext.IndexTreeNodePageNumbers
        .Where(pn => pn.SessionId == sessionId && pn.SessionDayId == sessionDayId)
        .ToList();

    List<int> nodeIds = pageNumbersforSessionDay
        .Select(pn => pn.IndexTreeNodeId)
        .ToList();

    List<IndexTreeNode> sessionNodes = _evaDbContext.IndexTreeNodes
        .Include(n => n.PrimaryTerm)
        .Include(n => n.SecondaryTerm)
        .Include(n => n.TertiaryTerm)
        .Include(n => n.QuaternaryTerm)
        .Where(n =>
                n.SessionId == sessionId &&
                nodeIds.Contains(n.Id))
        .ToList();

    List<IndexTreeNodeDto> rootNodes = GetNodeDtoFromQuery(sessionNodes);
    if (rootNodes == null || !rootNodes.Any())
    {
        return null;
    }

    List<IndexTreeNodePageNumber> pageNumbers = _evaDbContext.IndexTreeNodePageNumbers
        .Where(pn => pn.SessionId == sessionId && pn.SessionDayId == sessionDayId)
        .ToList();

    foreach (IndexTreeNodeDto primary in rootNodes)
    {

        if (primary.ChildNodes == null)
        {
            continue;
        }

        foreach (IndexTreeNodeDto secondary in primary.ChildNodes)
        {

            secondary.PageNumbers = pageNumbers
                .Where(pn => pn.IndexTreeNodeId == secondary.Id && pn.PageNumber != null)
                .Select(pn => pn.PageNumber.GetValueOrDefault())
                .ToList();

            if (secondary.ChildNodes == null)
            {
                continue;
            }

            foreach (IndexTreeNodeDto tertiary in secondary.ChildNodes)
            {

                tertiary.PageNumbers = pageNumbers
                    .Where(pn => pn.IndexTreeNodeId == tertiary.Id && pn.PageNumber != null)
                    .Select(pn => pn.PageNumber.GetValueOrDefault())
                    .ToList();

                if (tertiary.ChildNodes == null)
                {
                    continue;
                }

                foreach (IndexTreeNodeDto quaternary in tertiary.ChildNodes)
                {
                    quaternary.PageNumbers = pageNumbers
                        .Where(pn => pn.IndexTreeNodeId == quaternary.Id && pn.PageNumber != null)
                        .Select(pn => pn.PageNumber.GetValueOrDefault())
                        .ToList();
                }

            }

        }
    }

    return rootNodes;
}

here is the code for adding a node 
public void AddNode(int sessionId, int sessionDayId, int? termId, string nodeText, int? nodeId)
{
    ValidateSessionAndDay(sessionId, sessionDayId, out _, out _);

    IndexTreeNode parentNode;
    IndexTreeNode newNode = new IndexTreeNode
    {
        SessionId = sessionId,
                  SessionDayId = sessionDayId,
                  NodeText = nodeText,
                  CreatedBy = _userContext.Username,
                  ModifiedBy = _userContext.Username,
                  Created = DateTime.Now,
                  Modified = DateTime.Now,
    };

    if (nodeId.HasValue)
    {
        parentNode = _evaDbContext.IndexTreeNodes
            .FirstOrDefault(n => n.Id == nodeId && n.SessionId == sessionId)
            ?? throw new InvalidOperationException("Parent node does not exist.");

        if (parentNode.SecondaryTermId == null && parentNode.NodeText == null)
        {
            newNode.SecondaryTermId = termId;
        }
        else if (parentNode.TertiaryTermId == null && parentNode.NodeText == null)
        {
            newNode.SecondaryTermId = parentNode.SecondaryTermId;
            newNode.TertiaryTermId = termId;
        }
        else if (parentNode.QuaternaryTermId == null && parentNode.NodeText == null)
        {
            newNode.SecondaryTermId = parentNode.SecondaryTermId;
            newNode.TertiaryTermId = parentNode.TertiaryTermId;
            newNode.QuaternaryTermId = termId;
        }
        newNode.PrimaryTermId = parentNode.PrimaryTermId;
    }
    else
    {
        if (termId.HasValue)
        {
            IndexTreeNode primaryNode = _evaDbContext.IndexTreeNodes
                .FirstOrDefault(n =>
                        n.SessionId == sessionId &&
                        n.PrimaryTermId == termId &&
                        n.SecondaryTermId == null &&
                        n.TertiaryTermId == null &&
                        n.QuaternaryTermId == null);

            if (primaryNode != null)
            {
                throw new InvalidOperationException("The primary node already exists.");
            }
        }
        parentNode = null;
        newNode.PrimaryTermId = termId.GetValueOrDefault();
    }

    IndexTreeNodePageNumber pageNumber = new IndexTreeNodePageNumber
    {
        IndexTreeNode = newNode,
                      SessionId = sessionId,
                      SessionDayId = sessionDayId,
                      PageNumber = null,
                      CreatedBy = _userContext.Username,
                      ModifiedBy = _userContext.Username,
                      Created = DateTime.Now,
                      Modified = DateTime.Now,
    };

    _evaDbContext.IndexTreeNodes.Add(newNode);
    _evaDbContext.IndexTreeNodePageNumbers.Add(pageNumber);
    _evaDbContext.SaveChanges();
}

here is the code for adding a node with a term that doesn't exist
public void AddTermThenAddNode(int sessionId, int sessionDayId, IndexTermDto request, int? parentNodeId)
{
    ValidateSessionAndDay(sessionId, sessionDayId, out _, out _);

    if (string.IsNullOrEmpty(request.Term))
    {
        throw new InvalidOperationException("Term name cannot be empty.");
    }

    string lowerTerm = request.Term.Trim().ToLower();
    IndexTerm existingIndexTerm = _evaDbContext.IndexTerms
        .FirstOrDefault(it => it.Term.ToLower() == lowerTerm);

    if (existingIndexTerm != null)
    {
        throw new InvalidOperationException($" The term '{existingIndexTerm.Term}' already exists.");
    }

    IndexTreeNode parentNode = _evaDbContext.IndexTreeNodes
        .FirstOrDefault(n => n.Id == parentNodeId && n.SessionId == sessionId);
    int level = parentNode == null ? 1 : GetNodeLevel(parentNode);
    IndexTerm indexTerm = null;
    if (level < 3)
    {
        indexTerm = new IndexTerm
        {
            Term = request.Term,
                 IsSenator = request.IsSenator,
                 CreatedBy = _userContext.Username,
                 ModifiedBy = _userContext.Username,
                 Created = DateTime.Now,
                 Modified = DateTime.Now,
        };

        _evaDbContext.IndexTerms.Add(indexTerm);
        _evaDbContext.SaveChanges();
    }

    AddNode(sessionId, sessionDayId, indexTerm?.Id, request.Term, parentNodeId);
}

below is the data in the indexTreeNode table in the db:
Id	SessionId	SessionDayId	PrimaryTermId	SecondaryTermId	TertiaryTermId	QuaternaryTermId
4009	1	1009	6046	NULL	NULL	NULL
4010	1	1009	6047	NULL	NULL	NULL

here are their respective terms:
Id	Term	IsSenator
6046	paospdoapsdopasod	0
6047	nnnnnnnnnnnnnn	0

I'm attempting to add the ability for the user to create a
node without a term

The issue is when I add a term, the tree builder methods return a tree structure that is incorrect.
with the above data I end up getting back a tree structure of the primary node and blank child nodes
all the way to the quaternaryNode.

new node
    blank node
        blank node
            blank node

This happens anytime I try to add a new node with a term that doesn't exist in the db.
This also happens when I add a primary node with an existing term and then add a secondary term that 
is a brand new term.
This doesn't happen when I select an existing term to add to the tree.

Fix this issue as if you're an engineer at a company that creates software for the US Senate.
Make the solution as minimal as possible.

But make as little changes as possible to accomplish this task

Give me a solution to this problem. make it as minimal as possible. 
Don't comment your code. Make it self-explanatory.
Explicitly type all variables and methods. do not use var.

if you do this well there will be a monetary tip!


----

below is the child component ui html for the node component:
<mat-card>
    <div class="filters-container">
        <mat-form-field appearance="fill" class="white-form-field">
            <mat-label>Search and select a term</mat-label>
            <input
                type="text"
                placeholder="Search"
                [formControl]="filterNodesControl"
                [value]="filterNodesControl.value?.name || filterNodesControl.value"
                matInput
                #searchInputField
                [matAutocomplete]="auto" />
            <mat-autocomplete
                #auto="matAutocomplete"
                autoActiveFirstOption
                aria-label="Search and select a term"
                (optionSelected)="null">
                <mat-option *ngFor="let term of terms" [value]="term">
                    {{ term.term }}
                </mat-option>
            </mat-autocomplete>
        </mat-form-field>
    </div>
    <div class="tree-container">
        <div class="new-primary-term-container">
            <button mat-raised-button (click)="openTermSearch($event)">Add Primary Index</button>
        </div>
        <div *ngFor="let node of indexTree">
            <app-index-builder-node
                (refresh)="refresh()"
                [node]="node"
                [level]="1"
                [ancestors]="[node.termId]"
            ></app-index-builder-node>
        </div>
    </div>
</mat-card>

<app-term-search
    *ngIf="isSearchShowing"
    [position]="searchComponentPosition"
    (termSelected)="termSelected($event)"
    (closeEmitter)="closeTermSearch()"
></app-term-search>

below is the corresponding typescript:
@Component({
    selector: 'app-index-builder-node',
    templateUrl: './index-builder-node.component.html',
    styleUrls: ['./index-builder-node.component.css']
})
export class IndexBuilderNodeComponent {

    @Input() public node: IndexTreeNodeDto;
    @Input() public level: number = 0;
    @Input() public ancestors: number[] = [];
    @Output() public refresh: EventEmitter<boolean> = new EventEmitter<boolean>();

    public searchComponentPosition: VectorPosition;
    public isSearchShowing: boolean = false;
    public nodeBeingEdited: IndexTreeNodeDto;
    public isRenaming: boolean = false;

    constructor(
        private codegenService: IndexTreeCodegenService,
        private sessionStateService: SessionStateService,
        private notifierService: NotifierService,
        private dialog: MatDialog,
        private indexingStateService: IndexingStateService
    ) { }

    private get sessionId(): number {
        return this.sessionStateService.getCurrentSessionId();
    }

    private get sessionDayId(): number {
        return this.sessionStateService.getCurrentSessionDay().id;
    }

    public getAncestors(): number[] {
        let ancestors = [...this.ancestors];
        ancestors.push(this.node.termId);
        return ancestors;
    }

    public termSelected(term: IndexTermDto): void {
        const request: IndexTreeNodeAddDto = {
            termId: term.id,
            level: this.level + 1,
            primaryTermId: this.ancestors.length > 0 ? this.ancestors[0] : null,
            secondaryTermId: this.ancestors.length > 1 ? this.ancestors[1] : null,
            tertiaryTermId: this.ancestors.length > 2 ? this.ancestors[2] : null,
        };

        this.codegenService.apiIndexTreeSessionIdSessionDayIdAddNodePost(this.sessionId, this.sessionDayId, request)
            .subscribe((): void => {
                this.notifierService.notify('success', 'Successfully added index term');
                this.refresh.emit(true);
                this.isSearchShowing = false;
            });
    }

    public renameNode($event: MouseEvent, node: IndexTreeNodeDto): void {
        this.isRenaming = true;
        this.toggleSearch($event, node);
    }

    public toggleSearch($event: MouseEvent, node: IndexTreeNodeDto): void {
        this.indexingStateService.closeAllSearchDialogs.next(true);
        this.nodeBeingEdited = node;
        this.isSearchShowing = !this.isSearchShowing;

        if (this.isSearchShowing) {
            const target = $event.target as HTMLElement;
            const rect = target.getBoundingClientRect();

            const position = {
                x: rect.left,
                y: rect.bottom + 10
            } as VectorPosition;
            this.searchComponentPosition = position;
        }
    }

}

below is the parent component to the above:

<mat-card>
    <div class="filters-container">
        <mat-form-field appearance="fill" class="white-form-field">
            <mat-label>Search and select a term</mat-label>
            <input
                type="text"
                placeholder="Search"
                [formControl]="filterNodesControl"
                [value]="filterNodesControl.value?.name || filterNodesControl.value"
                matInput
                #searchInputField
                [matAutocomplete]="auto" />
            <mat-autocomplete
                #auto="matAutocomplete"
                autoActiveFirstOption
                aria-label="Search and select a term"
                (optionSelected)="null">
                <mat-option *ngFor="let term of terms" [value]="term">
                    {{ term.term }}
                </mat-option>
            </mat-autocomplete>
        </mat-form-field>
    </div>
    <div class="tree-container">
        <div class="new-primary-term-container">
            <button mat-raised-button (click)="openTermSearch($event)">Add Primary Index</button>
        </div>
        <div *ngFor="let node of indexTree">
            <app-index-builder-node
                (refresh)="refresh()"
                [node]="node"
                [level]="1"
                [ancestors]="[node.termId]"
            ></app-index-builder-node>
        </div>
    </div>
</mat-card>

<app-term-search
    *ngIf="isSearchShowing"
    [position]="searchComponentPosition"
    (termSelected)="termSelected($event)"
    (closeEmitter)="closeTermSearch()"
></app-term-search>

and the corresponding typescript:

@Component({
    selector: 'app-index-builder',
    templateUrl: './index-builder.component.html',
    styleUrls: ['./index-builder.component.css']
})
export class IndexBuilderComponent extends DestroyableComponent {

    public indexTree: IndexTreeNodeDto[] = [];
    public filterNodesControl: FormControl = new FormControl('');
    public form = this.fb.group({
        filterNodesControl: this.filterNodesControl,
    });
    public terms: IndexTreeNodeDto[] = [];
    public isSearchShowing: boolean = false;
    public searchComponentPosition: VectorPosition;

    constructor(
        private fb: FormBuilder,
        private codegenService: IndexTreeCodegenService,
        private sessionService: SessionStateService,
        private notifierService: NotifierService,
        private indexingStateService: IndexingStateService,
    ) {
        super();
        this.listenToFilterNodesChanges();
        this.getIndexTree();
        this.listenToSelectedSessionDay();
    }

    private get sessionId(): number {
        return this.sessionService.getCurrentSessionId();
    }

    private get sessionDayId(): number {
        return this.sessionService.getCurrentSessionDay().id;
    }

    public openTermSearch($event: MouseEvent): void {
        this.indexingStateService.closeAllSearchDialogs.next(true);
        this.isSearchShowing = !this.isSearchShowing;
        if (this.isSearchShowing) {
            const target = $event.target as HTMLElement;
            const rect = target.getBoundingClientRect();
            const position = { x: rect.left, y: rect.bottom + 10 } as VectorPosition;
            this.searchComponentPosition = position;
        }
    }

    public termSelected(term: IndexTermDto): void {
        // can only create primary terms from this part of the UI
        const request: IndexTreeNodeAddDto = {
            termId: term.id,
            level: 1,
            primaryTermId: null,
            secondaryTermId: null,
            tertiaryTermId: null,
        };
        this.codegenService.apiIndexTreeSessionIdSessionDayIdAddNodePost(
                this.sessionId, this.sessionDayId, request)
            .pipe(
                switchMap(() => this.treeIndexObservable()))
            .subscribe(() => {
                this.notifierService.notify('success', 'Term added to index');
            });
    }

}

i ommitted some code for brevity.

The problem i'm having is that the ancestors array only ever has multiple duplicates of the primary term id.

The idea behind it originally was to keep track of the ancestors of the node so that when the user selects a term from the search dialog, the term is added to the tree structure at the appropriate level.

I need the ancestors array to always contain all term ids from the root node to the current node. and I need it to be accessible in the child component. and I need it to be correct.

If there is a better way to solve this issue please let me know. 

As you can see in the termSelected method, I need the term ids that I need in order to correctly place the term that was selected.





----


The issue i'm running into is that the tree structure is being incorrectly fetched from the db 

here is the db data for the tree structure you see in the screenshot:
columns are
id, sessionid, primarytermid, secondarytermid, tertiarytermid, quaternarytermid
12	1	1009	1	NULL	NULL	NULL	NULL
13	1	1009	1	10	NULL	NULL	NULL
14	1	1009	1	1	2045	NULL	NULL
15	1	1009	1	1	1	1041	NULL

below is the json response built out from the GetIndexTreeBySessionDay method:

[ {  "id": 12,  "sessionId": 0,  "sessionDayId": 0,  "termId": 1,  "term": "Appropriations Bill",  "pageNumbers": null,  "childNodes": [   {    "id": 13,    "sessionId": 0,    "sessionDayId": 0,    "termId": 10,    "term": "Climate Change Resolution",    "pageNumbers": null,    "childNodes": []   },   {    "id": 14,    "sessionId": 0,    "sessionDayId": 0,    "termId": 1,    "term": "Appropriations Bill",    "pageNumbers": null,    "childNodes": [     {      "id": 14,      "sessionId": 0,      "sessionDayId": 0,      "termId": 2045,      "term": "Calebs Node",      "pageNumbers": null,      "childNodes": []     },     {      "id": 15,      "sessionId": 0,      "sessionDayId": 0,      "termId": 1,      "term": "Appropriations Bill",      "pageNumbers": null,      "childNodes": [       {        "id": 15,        "sessionId": 0,        "sessionDayId": 0,        "termId": 1041,        "term": "foobar",        "pageNumbers": null,        "childNodes": []       }      ]     }    ]   }  ] }]

Why am I getting duplicate Appropriations Bill terms in the json response?
------

with the above code I can add a node to a parent node.

but when I get the tree structure from the db, it does not return the child nodes. only the parent nodes.

I can see in the db that when I add a child node to a parent node, the child has the appropriate parent node id.

-------

create sql script that will mock up a tree structure of IndexTreeNode
Make it realistic such that I can use the data to test the UI and different api endpoints

then create a dotnet service method that will return the tree structure created in the sql script
with the given IndexTreeNodeDto model

--------
the tree structure should be able to go 3 levels deep
I like the idea of having a recursive template in the ui
such that I don't have to repeat the same html code for each of the children
the db schema should be able to handle this tree structure

Tech stack is angular with dotnet ef core and sql server

The list of available terms is already created in another feature
The list of terms is stored in a model like this:
public class IndexTerm
{
    public int Id { get; set; }
    public string Term { get; set; }
    public bool IsSenator { get; set; }
}

The list of IndexTerms is persisted throughout the lifetime of the app. it's an ever growing list

The index that my feature builds is just a tree structure of the IndexTerms
and the user can create a new one each year.
I'm trying to figure out how to store the data of the tree in the db.

nested set model:

public class IndexTree 
{
    public int Id { get; set; }
}


public class IndexTreeNodePageNumber 
{
    public int Id { get; set; }
    public int IndexTreeNodeId { get; set; }
    public int PageNumber { get; set; }
}


----
PROBLEM WITH THE INITIAL DB STRUCTURE

public class IndexTreeNode
{
    public int Id { get; set; }
    public int SessionId { get; set; }
    public int PrimaryTermId { get; set; }
    public int? SecondaryTermId { get; set; }
    public int? TertiaryTermId { get; set; }
    public int? QuaternaryTermId { get; set; }
    public virtual IndexTerm PrimaryTerm { get; set; }
    public virtual IndexTerm SecondaryTerm { get; set; }
    public virtual IndexTerm TertiaryTerm { get; set; }
    public virtual IndexTerm QuaternaryTerm { get; set; }
    public string CreatedBy { get; set; }
    public DateTime Created { get; set; }
    public DateTime Modified { get; set; }
    public string ModifiedBy { get; set; }
}

The issue you're encountering stems from how your database structure associates child nodes with their ancestors. Specifically, the `IndexTreeNode` table uses `PrimaryTermId`, `SecondaryTermId`, `TertiaryTermId`, and `QuaternaryTermId` to define hierarchy, but these IDs are reused for multiple nodes when they reference the same terms. This causes ambiguity because nodes with the same `PrimaryTermId` are treated as if they share the same children.

### Analysis of the Problem

#### Current Structure
- The `PrimaryTermId`, `SecondaryTermId`, `TertiaryTermId`, and `QuaternaryTermId` columns define the levels of the hierarchy.
- A primary node (`PrimaryTermId`) and its children are determined by matching rows that have the same `PrimaryTermId`.
- If two primary nodes share the same `PrimaryTermId`, their children will also be shared, as there is no additional context or unique identifier to distinguish them.

#### Example Scenario
1. You add a primary node for the term "foo" with two child nodes.
2. You add another primary node for the term "foo."
3. When querying the database, both primary nodes reference the same `PrimaryTermId`, and their children are treated as shared because no unique relationship distinguishes the children of each "foo."

---

### Suggestions to Resolve the Issue

#### 1. Redesign the `IndexTreeNode` Table
Modify the structure to explicitly track parent-child relationships instead of relying on term IDs alone.

```csharp
public class IndexTreeNode
{
    public int Id { get; set; }
    public int SessionId { get; set; }
    public int? ParentNodeId { get; set; } // Self-referencing foreign key
    public int TermId { get; set; } // The term for this node
    public string CreatedBy { get; set; }
    public DateTime Created { get; set; }
    public DateTime Modified { get; set; }
    public string ModifiedBy { get; set; }

    public virtual IndexTreeNode ParentNode { get; set; } // Navigation property for parent
    public virtual ICollection<IndexTreeNode> ChildNodes { get; set; } // Navigation property for children
    public virtual IndexTerm Term { get; set; } // Navigation property for the term
}
```

- Replace the `PrimaryTermId`, `SecondaryTermId`, `TertiaryTermId`, and `QuaternaryTermId` columns with a single `ParentNodeId` column to define parent-child relationships.
- The `TermId` column identifies the term associated with each node.

#### 2. Adjust Query Logic
Update the query logic to recursively build the tree based on the `ParentNodeId` relationships.

```csharp
private async Task<List<IndexTreeNodeDto>> GetIndexTreeAsync(int sessionId)
{
    var rootNodes = await _evaDbContext.IndexTreeNodes
        .Where(n => n.SessionId == sessionId && n.ParentNodeId == null)
        .Include(n => n.Term)
        .ToListAsync();

    return rootNodes.Select(MapTreeNodeToDto).ToList();
}

private IndexTreeNodeDto MapTreeNodeToDto(IndexTreeNode node)
{
    return new IndexTreeNodeDto
    {
        Id = node.Id,
        TermId = node.TermId,
        Term = node.Term.Term,
        PageNumbers = new List<int>(), // Add your logic for page numbers
        ChildNodes = node.ChildNodes.Select(MapTreeNodeToDto).ToList()
    };
}
```

#### 3. Migration for Existing Data
Write a migration to refactor your existing data:
1. Create the `ParentNodeId` column.
2. Populate it based on the current hierarchy (using `PrimaryTermId`, `SecondaryTermId`, etc.).
3. Remove the `SecondaryTermId`, `TertiaryTermId`, and `QuaternaryTermId` columns.

---

### Advantages of This Approach
- **Flexibility**: Allows any number of levels, not just four.
- **Clear Relationships**: Distinguishes between nodes with the same term.
- **Consistency**: Eliminates ambiguity caused by shared `PrimaryTermId` values.

---

### Feasibility of the Current Structure
The current structure could work but is inherently limited. If you must retain it:
1. Introduce a unique identifier for each node (e.g., `NodeId`).
2. Ensure that child nodes are tied to `NodeId` instead of relying solely on `TermId`.

However, this approach may introduce significant complexity and is less robust than redesigning the schema.

Would you like help with crafting the migration script or further refining this implementation?
-------
        /*
         * finds all of the secondary nodes that belong to the primary node
         _db.IndexTreeNodes
         .Where(n => p.SessionId == sessionId &&
         p.PrimaryTermId == primaryTermId 
         && p.SecondaryTermId.HasValue 
         && !p.TertiaryTermId.HasValue 
         && !p.QuaternaryTermId.HasValue) 
         public class IndexTreeNodeDto
         {
         public int Id { get; set; }
         public int TermId { get; set; }
         public string Term { get; set; }
         public List<int> PageNumbers { get; set; }
         public List<IndexTreeNodeDto> ChildNodes { get; set; }
         }
         public class IndexTreeNodeDto
         {
         public int Id { get; set; }
         public int TermId { get; set; }
         public string Term { get; set; }
         public List<int> PageNumbers { get; set; }
         public List<IndexTreeNodeDto> ChildNodes { get; set; }
         }

         var nodes = await _context.IndexTreeNodes
         .Include(n => n.PrimaryTerm)
         .Include(n => n.PrimaryTermPageNumbers)
         .Include(n => n.SecondaryTerm)
         .Include(n => n.SecondaryTermPageNumbers)
         .Include(n => n.TertiaryTerm)
         .Include(n => n.TertiaryTermPageNumbers)
         .Include(n => n.QuaternaryTerm)
         .Include(n => n.QuaternaryTermPageNumbers)
         .Select(n => new IndexTreeNodeDto
         {
         Id = n.Id,
         PrimaryTerm = n.PrimaryTerm.Term,
         PrimaryTermPageNumbers = n.PrimaryTermPageNumbers.Select(p => p.Page).ToList(),

         SecondaryTerm = n.SecondaryTerm != null ? n.SecondaryTerm.Term : null,
         SecondaryTermPageNumbers = n.SecondaryTermPageNumbers.Select(p => p.Page).ToList(),

         TertiaryTerm = n.TertiaryTerm != null ? n.TertiaryTerm.Term : null,
         TertiaryTermPageNumbers = n.TertiaryTermPageNumbers.Select(p => p.Page).ToList(),

         QuaternaryTerm = n.QuaternaryTerm != null ? n.QuaternaryTerm.Term : null,
         QuaternaryTermPageNumbers = n.QuaternaryTermPageNumbers.Select(p => p.Page).ToList()
         })
         .ToListAsync();



         so it sort of depends on where you're working to build the tree exactly... but your DTO doesn't have to match the data...


         so we have our model already and i'll assume there's a navigation property for the terms ex:

         public class TreeNodeIndex {

         int PrimaryTermId;

         Term PrimaryTerm;

         }


         so if you're "Term" dto is something like:

         public class TermDto {

        int id;

        string Word;

        IEnumerable<TermDto> ChildTerms;

    }


    Assuming as well that the query is order by PrimaryTerm, SecondaryTerm...

        Dictionary<string, TermDto> termMap = new();

    List<TermDto> primarys = now();

    foreach(IndexTreeNode node in results) {
        if(!termMap.TryGetValue(node.PrimaryTermId, out TermDto primaryNode)) {
            var termdto = new TermDto() { stuff };
            termMap.Add(node.PrimaryTermId, termdto);
            primarys.Add(termdto);
        }
        if(node.SecondaryTermId == null) { continue; }
        string key = node.PrimaryTermId + "_" + node.SecondaryTermId;
        if(!termMap.TryGetValue(key, out TermDto secondaryNode)) {
            // since the unique value of "primaryTermId_secondaryTermId" doesn't exist, we know this parent/child relationship doesn't exist
            // so add they key and add this term as a child node to the primary node
            secondaryNode = new() { stuff };
            termMap.Add(key, secondaryNode);
            primaryNode.ChildTerms.Add(secondaryNode);
        }
        if(node.TertiaryTermId == null) { continue; }
        key += "_" + node.TertiaryTermId;
        if(!termMap.TryGetValue(key, out TermDto tertiaryNode)) {
            // since the unique value of "primaryTermId_secondaryTermId_tertiaryTermId" doesn't exist, we know this parent/child relationship doesn't exist
            // so add they key and add this term as a child node to the secondary node
            tertiaryNode = new() { stuff };
            termMap.Add(key, tertiaryNode);
            secondaryNode.ChildTerms.Add(tertiaryNode);
        }
        if(node.QuaternaryTermId == null) { continue; }
        // since this is a quaternary and we already have the tertiary, we just add this term as a child to the tertiary
        tertiaryNode.ChildTerms.Add(new TermDto { stuff });
    }

    get all the page numbers for for the session and day 
    map with (indexTreeNodeId, List<IndexTreeNodePageNumber>)
    
    1 _ 2


    */




------

Page numbers are the only data point that are specific to a day
 
table of 

session id 
session day id
index tree node id
page number nullable
one record per page number
new record with no page number just associates the node to the day

----
UI CODE

I have a main parent component called 'index-builder.component.ts' that will hold the tree structure.
I have a child component called 'index-node.component.ts' that will be responsible
for rendering each node.

here is the html structure of the parent component:

    <div class="tree-container">
        <div *ngFor="let node of indexTree">
            <app-index-builder-node [node]="node"></app-index-builder-node>
        </div>
    </div>
here is the html structure of the child component:


    <div class="node" [ngStyle]="{ 'margin-left': (level * 20) + 'px' }">
    <button (click)="null">Add</button>
    <span>{{ node.term }}</span>
    <button (click)="null">Delete</button>
    <button (click)="null">Add Page Number</button>

    <!--<span *ngFor="let page of node.PageNumbers">{{ page }}</span>-->

    <div class="child-nodes" *ngFor="let childNode of node.childNodes">
        <app-index-builder-node [node]="childNode" [level]="level + 1"></app-index-builder-node>
    </div>
</div>


node css:

.node {
  padding: 10px;
  margin-bottom: 10px;
  border-left: 2px solid black;
  box-shadow: 0px 7px 44px 19px rgba(0,0,0,0.1);
}

.node[level='0'] {
}

.node[level='1'] {
}

.node[level='2'] {
}

.node[level='3'] {
}

.term-name {
  cursor: pointer;
  transition: background-color 0.3s;
  padding: 5px;
  border-radius: 5px;
}

.term-name:hover {
    background-color: #f0f0f0;
}

node html

<div class="node" [ngStyle]="{ 'margin-left': (level * 20) + 'px' }">
    <button mat-button *ngIf="level < 3" (click)="toggleSearch($event, node)">Add</button>
    <span (click)="toggleSearch($event, node)" class="term-name">{{ node.term }}</span>
    <button mat-button class="ms-1" (click)="deleteNode()">Delete</button>
    <button mat-button (click)="null">Add Page Number</button>

    <!--<span *ngFor="let page of node.PageNumbers">{{ page }}</span>-->

    <div class="child-nodes" *ngFor="let childNode of node.childNodes">
        <app-index-builder-node (refresh)="refreshTree()" [node]="childNode" [level]="level + 1"></app-index-builder-node>
    </div>
</div>

<app-term-search
    *ngIf="isSearchShowing"
    [position]="searchComponentPosition"
    (termSelected)="termSelected($event)"
    (closeEmitter)="closeTermSearch()"
></app-term-search>

---- 
old api code


here is the api code for getting the tree structure from the db and adding a node to the tree:

        public async Task<List<IndexTreeNodeDto>> GetIndexTreeAsync(int sessionId)
        {
            List<IndexTreeNode> rootNodes = await _evaDbContext.IndexTreeNodes
                .Where(n => n.SessionId == sessionId && n.ParentNodeId == null)
                .Include(n => n.Term)
                .ToListAsync();

            return rootNodes.Select(MapTreeNodeToDto).ToList();
        }

        private IndexTreeNodeDto MapTreeNodeToDto(IndexTreeNode node)
        {
            return new IndexTreeNodeDto
            {
                Id = node.Id,
                TermId = node.TermId,
                Term = node.Term.Term,
                PageNumbers = new List<int>(), // TODO
                ChildNodes = node.ChildNodes?.Select(MapTreeNodeToDto).ToList()
            };
        }
        public void AddNode(int sessionId, IndexTreeNodeDto nodeDto)
        {
            ValidateSession(sessionId);

            
            if (nodeDto.Id > 0)
            {
                IndexTreeNode parentNode = _evaDbContext.IndexTreeNodes
                    .AsNoTracking()
                    .FirstOrDefault(n => n.Id == nodeDto.Id && n.SessionId == sessionId)
                    ?? throw new InvalidOperationException(
                                "Parent node does not exist.");
            }

            
            IndexTreeNode newNode = new()
            {
                SessionId = sessionId,
                TermId = nodeDto.TermId,
                ParentNodeId = nodeDto.Id > 0 ? nodeDto.Id : null, 
                CreatedBy = _userContext.Username,
                ModifiedBy = _userContext.Username,
                Created = DateTime.UtcNow,
                Modified = DateTime.UtcNow
            };

            _evaDbContext.IndexTreeNodes.Add(newNode);
            _evaDbContext.SaveChanges(); 
        }

below is the ui method for when the user selects a new term from any level below the primary level:
public termSelected(term: IndexTermDto): void {
    const request: IndexTreeNodeAddDto = {
termId: term.id,
        level: this.level + 1,
        primaryTermId: this.ancestors[0] || null,
        secondaryTermId: this.ancestors[1] || null,
        tertiaryTermId: this.ancestors[2] || null,
    };

    if (this.isRanaming) {
    } else {
        this.codegenService.apiIndexTreeSessionIdSessionDayIdAddNodePost(this.sessionId, this.sessionDayId, request)
            .subscribe((): void => {
                    this.notifierService.notify('success', 'Successfully added index term');
                    this.refresh.emit(true);
                    this.isSearchShowing = false;
                    });
    }
}

below is the html structure for the node component:
<div class="node" [attr.level]="level" [ngStyle]="{ 'margin-left': (level * 20) + 'px' }">
    <div class="inner-node">
        <div class="node-left-side">
            <button mat-button *ngIf="level < 3" (click)="toggleSearch($event, node)">Add</button>
            <button mat-button (click)="renameNode($event, node)" >{{ node.term }}</button>
        </div>

        <div *ngIf="level > 0" class="page-numbers-container" (click)="null">
            <span class="page-dots"></span>
            <span class="page-numbers">
                <span *ngFor="let pageNumber of node.pageNumbers; let last = last;" class="page-number">
                    <span *ngIf="!last">{{ pageNumber }}, </span>
                    <span *ngIf="last">{{ pageNumber }}</span>
                </span>
            </span>
        </div>

        <div class="node-right-btns">
            <button mat-button class="ms-1" (click)="deleteNode()">Delete</button>
            <!--<button mat-button (click)="null">Page Number</button>-->
        </div>
    </div>


    <div class="child-nodes" *ngFor="let childNode of node.childNodes">
        <app-index-builder-node
            (refresh)="refreshTree()"
            [node]="childNode"
            [level]="level + 1"
            [ancestors]="getAncestors()"
        ></app-index-builder-node>
    </div>
</div>

<app-term-search
    *ngIf="isSearchShowing"
    [position]="searchComponentPosition"
    (termSelected)="termSelected($event)"
    (closeEmitter)="closeTermSearch()"
></app-term-search>



----
- Should I add filtering nodes in this iteration?
- should I add the ability to add the new term as a senator in this iteration?
- collapsable nodes

TODO:
- Sort the tree structure by term name alphabetically
- Refresh tree when editing a searched subtree
- Adding a new term to replace the old one when renaming

TEST STEPS
- add primary, secondary, tertiary, quaternary nodes
- rename a node
- add an existing primary to another session day
- add page numbers to multiple nodes 
- delete a node
- check that alphabetical sorting is working
- add a new term from the search dialog














